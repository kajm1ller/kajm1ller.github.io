<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Kaj Simulator</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden;
            cursor: crosshair;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            font-family: Arial, sans-serif;
            z-index: 100;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: rgb(255, 255, 255);
            background: rgba(0,0,0,0.8);
            padding: 20px 40px;
            border-radius: 10px;
            font-family: Arial, sans-serif;
            font-size: 24px;
            z-index: 200;
        }
        #ragdoll-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255,0,0,0.3);
            display: none;
            z-index: 98;
            pointer-events: none;
        }
        #ragdoll-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-family: Arial, sans-serif;
            font-size: 32px;
            text-shadow: 2px 2px 4px black;
        }
        canvas {
            cursor: crosshair;
        }

        /* Mobile touch controls */
        #mobile-controls {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 110;
        }
        #mobile-controls.active {
            display: block;
        }
        #joystick-zone {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 150px;
            height: 150px;
            pointer-events: auto;
            touch-action: none;
        }
        #joystick-base {
            position: absolute;
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: rgba(255,255,255,0.15);
            border: 2px solid rgba(255,255,255,0.3);
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }
        #joystick-stick {
            position: absolute;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(255,255,255,0.45);
            border: 2px solid rgba(255,255,255,0.6);
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            transition: none;
        }
        #mobile-buttons {
            position: absolute;
            bottom: 30px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            pointer-events: auto;
            touch-action: none;
        }
        .mobile-btn {
            width: 64px;
            height: 64px;
            border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.4);
            background: rgba(0,0,0,0.4);
            color: white;
            font-family: Arial, sans-serif;
            font-size: 11px;
            font-weight: bold;
            text-align: center;
            line-height: 64px;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }
        .mobile-btn:active {
            background: rgba(255,255,255,0.25);
        }
        #mobile-btn-shoot {
            background: rgba(180,40,40,0.5);
            border-color: rgba(255,80,80,0.6);
        }
        #mobile-btn-interact {
            background: rgba(40,120,40,0.5);
            border-color: rgba(80,255,80,0.6);
        }
        #mobile-btn-weapon {
            background: rgba(40,40,140,0.5);
            border-color: rgba(80,80,255,0.6);
            font-size: 9px;
            line-height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #mobile-btn-camera {
            background: rgba(140,40,140,0.5);
            border-color: rgba(200,80,200,0.6);
            font-size: 10px;
        }
        /* Hide desktop-only elements on mobile */
        @media (max-width: 768px), (pointer: coarse) {
            #coords { display: none !important; }
            #weapon-display { bottom: 110px !important; right: 90px !important; font-size: 12px !important; padding: 6px 10px !important; }
            #status-hud { font-size: 11px !important; padding: 6px 8px !important; }
            .dialog-option { font-size: 14px !important; padding: 14px !important; }
            #pole-dialog, #no-answer-dialog, #remoro-dialog, #remoro-talk-dialog, #dead-boy-dialog, #house-dialog, #corpse-dialog, #combat-ui {
                width: 90vw !important;
                max-width: 90vw !important;
                left: 5vw !important;
                transform: none !important;
                bottom: 15px !important;
                font-size: 14px !important;
                box-sizing: border-box !important;
                padding: 14px !important;
                z-index: 200 !important;
            }
            #combat-ui {
                top: auto !important;
                bottom: 15px !important;
            }
            #house-dialog button, #corpse-dialog button, #combat-actions button {
                padding: 14px 8px !important;
                font-size: 14px !important;
                min-height: 48px !important;
                touch-action: manipulation !important;
            }
            #corpse-dialog > div:last-child {
                flex-wrap: wrap !important;
            }
            #corpse-dialog button {
                flex: 1 1 45% !important;
            }
            #combat-log {
                height: 80px !important;
                -webkit-overflow-scrolling: touch !important;
                touch-action: pan-y !important;
            }
            #combat-actions {
                flex-wrap: wrap !important;
            }
            #combat-actions button {
                flex: 1 1 45% !important;
            }
            #exit-indicator, #bed-indicator, #talk-indicator {
                font-size: 15px !important;
                padding: 12px 20px !important;
            }
            .key-hint { display: none !important; }
        }
    </style>
</head>
<body>
    
    <div id="coords" style="position:absolute;top:10px;right:10px;color:white;background:rgba(0,0,0,0.7);padding:10px;border-radius:5px;font-family:monospace;font-size:14px;z-index:100;">
        X: 0.00<br>Y: 0.00<br>Z: 0.00
    </div>
    <div id="status-hud" style="position:absolute;top:10px;left:10px;color:white;background:rgba(0,0,0,0.7);padding:10px;border-radius:5px;font-family:Arial,sans-serif;font-size:14px;z-index:100;">
        HP: <span id="player-hp">120</span> | Kaj Coins: <span id="kaj-coins">0</span>
    </div>
    <div id="name-input" style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:white;background:rgba(0,0,0,0.9);padding:30px 50px;border-radius:10px;font-family:Arial,sans-serif;font-size:20px;z-index:200;text-align:center;">
        <div style="margin-bottom:15px;">NAME</div>
        <input type="text" id="player-name" maxlength="20" style="padding:10px;font-size:18px;border:none;border-radius:5px;width:200px;text-align:center;" placeholder="Your Name">
        <br><br>
        <button id="join-btn" style="padding:12px 30px;font-size:18px;cursor:pointer;border:none;border-radius:5px;background:#000000;color:white;">Join Game</button>
    </div>
    <div id="loading">Loading map...</div>
    <div id="dev-hud" style="display:none;position:absolute;top:50px;left:50%;transform:translateX(-50%);color:#0f0;background:rgba(0,0,0,0.8);padding:8px 18px;border-radius:6px;font-family:monospace;font-size:14px;z-index:200;pointer-events:none;white-space:pre;">DEV FLY MODE\nWASD + Space/Shift | Ctrl = Sprint | F12 = Exit</div>
    <div id="ragdoll-overlay"><div id="ragdoll-text"></div></div>
    <div id="hurt-flash" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(255,0,0,0.35);z-index:180;pointer-events:none;"></div>
    <div id="death-screen" style="display:none;position:fixed;top:0;left:0;width:100%;height:100%;background:#000 url('/media/deathstuff/deathscreen.jpg') center center / cover no-repeat;z-index:999;pointer-events:none;"></div>
    <div id="transition-overlay" style="position:absolute;top:0;left:0;width:100%;height:100%;background:black;opacity:0;pointer-events:none;z-index:150;transition:opacity 0.5s ease-in-out;"></div>
    <div id="pole-dialog" style="display:none;position:absolute;bottom:50px;left:50%;transform:translateX(-50%);width:600px;background:rgba(0,0,0,0.85);border:2px solid #444;border-radius:10px;padding:20px;font-family:Arial,sans-serif;z-index:160;">
        <div style="color:#fff;font-size:16px;line-height:1.5;margin-bottom:20px;">A young boy stands before a broken telephone pole. He asks you "Should we call emergency services?"</div>
        <div id="dialog-options">
            <div class="dialog-option" data-option="1" style="color:#7cff7c;padding:10px;margin:5px 0;cursor:pointer;border:1px solid #444;border-radius:5px;transition:background 0.2s;">1. Call emergency services</div>
            <div class="dialog-option" data-option="2" style="color:#7cff7c;padding:10px;margin:5px 0;cursor:pointer;border:1px solid #444;border-radius:5px;transition:background 0.2s;">2. "I'll give you a dollar if you grab the wire with both hands"</div>
            <div class="dialog-option" data-option="3" style="color:#7cff7c;padding:10px;margin:5px 0;cursor:pointer;border:1px solid #444;border-radius:5px;transition:background 0.2s;">3. Touch the wire yourself</div>
        </div>
    </div>
    <div id="no-answer-dialog" style="display:none;position:absolute;bottom:50px;left:50%;transform:translateX(-50%);width:600px;background:rgba(0,0,0,0.85);border:2px solid #444;border-radius:10px;padding:20px;font-family:Arial,sans-serif;z-index:160;">
        <div style="color:#fff;font-size:16px;line-height:1.5;margin-bottom:20px;">No one picked up.</div>
        <div id="no-answer-continue" style="color:#7cff7c;padding:10px;margin:5px 0;cursor:pointer;border:1px solid #444;border-radius:5px;transition:background 0.2s;text-align:center;">Continue</div>
    </div>
    <div id="remoro-dialog" style="display:none;position:absolute;bottom:50px;left:50%;transform:translateX(-50%);width:600px;background:rgba(0,0,0,0.85);border:2px solid #444;border-radius:10px;padding:20px;font-family:Arial,sans-serif;z-index:160;">
        <div style="color:#ff8c00;font-size:14px;margin-bottom:5px;">Remoro</div>
        <div style="color:#fff;font-size:16px;line-height:1.5;margin-bottom:20px;">"Lmfao get fucked"</div>
        <div id="remoro-continue" style="color:#7cff7c;padding:10px;margin:5px 0;cursor:pointer;border:1px solid #444;border-radius:5px;transition:background 0.2s;text-align:center;">Continue</div>
    </div>
    <div id="remoro-talk-dialog" style="display:none;position:absolute;bottom:50px;left:50%;transform:translateX(-50%);width:600px;background:rgba(0,0,0,0.85);border:2px solid #444;border-radius:10px;padding:20px;font-family:Arial,sans-serif;z-index:160;">
        <div style="color:#ff8c00;font-size:14px;margin-bottom:5px;">Remoro</div>
        <div id="remoro-talk-text" style="color:#fff;font-size:16px;line-height:1.5;margin-bottom:20px;"></div>
        <div id="remoro-talk-continue" style="color:#7cff7c;padding:10px;margin:5px 0;cursor:pointer;border:1px solid #444;border-radius:5px;transition:background 0.2s;text-align:center;">Continue</div>
    </div>
    <div id="dead-boy-dialog" style="display:none;position:absolute;bottom:50px;left:50%;transform:translateX(-50%);width:600px;background:rgba(0,0,0,0.85);border:2px solid #444;border-radius:10px;padding:20px;font-family:Arial,sans-serif;z-index:160;">
        <div style="color:#fff;font-size:16px;line-height:1.5;margin-bottom:20px;">His burnt corpse lies motionless in the street. On top of his remains lies a crumpled dollar bill.</div>
        <div id="dead-boy-continue" style="color:#7cff7c;padding:10px;margin:5px 0;cursor:pointer;border:1px solid #444;border-radius:5px;transition:background 0.2s;text-align:center;">Continue</div>
    </div>
    <div id="talk-indicator" style="display:none;position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);color:#7cff7c;font-family:Arial,sans-serif;font-size:18px;font-weight:bold;background:rgba(0,0,0,0.6);padding:8px 16px;border-radius:5px;z-index:100;pointer-events:none;"><span class='key-hint'>(E) </span>Talk</div>
    <div id="crosshair" style="display:none;position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);z-index:100;pointer-events:none;">
        <div style="position:absolute;width:20px;height:2px;background:rgba(255,255,255,0.8);left:-10px;top:-1px;"></div>
        <div style="position:absolute;width:2px;height:20px;background:rgba(255,255,255,0.8);left:-1px;top:-10px;"></div>
    </div>
    <div id="weapon-display" style="display:none;position:absolute;bottom:20px;right:20px;color:white;background:rgba(0,0,0,0.7);padding:15px 20px;border-radius:5px;font-family:Arial,sans-serif;font-size:16px;z-index:100;pointer-events:none;">
        <span id="weapon-name">Pistol</span>
    </div>
    <div id="house-dialog" style="display:none;position:absolute;bottom:40px;left:50%;transform:translateX(-50%);width:640px;background:rgba(0,0,0,0.85);border:2px solid #444;border-radius:10px;padding:20px;font-family:Arial,sans-serif;z-index:170;">
        <div style="color:#fff;font-size:16px;line-height:1.5;margin-bottom:20px;" id="house-dialog-text"></div>
        <div style="display:flex;gap:10px;">
            <button id="house-leave" style="flex:1;padding:10px 12px;cursor:pointer;border:none;border-radius:5px;background:#222;color:white;">Leave</button>
            <button id="house-attack" style="flex:1;padding:10px 12px;cursor:pointer;border:none;border-radius:5px;background:#5a1f1f;color:white;">Attack</button>
        </div>
    </div>
    <div id="corpse-dialog" style="display:none;position:absolute;bottom:40px;left:50%;transform:translateX(-50%);width:640px;background:rgba(0,0,0,0.85);border:2px solid #444;border-radius:10px;padding:20px;font-family:Arial,sans-serif;z-index:175;">
        <div style="color:#fff;font-size:16px;line-height:1.5;margin-bottom:20px;" id="corpse-dialog-text">The owner is dead. What do you do?</div>
        <div style="display:flex;gap:10px;">
            <button id="corpse-loot" style="flex:1;padding:10px 12px;cursor:pointer;border:none;border-radius:5px;background:#244a2f;color:white;">Loot Corpse</button>
            <button id="corpse-eat" style="flex:1;padding:10px 12px;cursor:pointer;border:none;border-radius:5px;background:#5a2f1f;color:white;">Eat Corpse</button>
            <button id="corpse-remoro" style="flex:1;padding:10px 12px;cursor:pointer;border:none;border-radius:5px;background:#3b2a5a;color:white;">Remoro's Choice</button>
            <button id="corpse-leave" style="flex:1;padding:10px 12px;cursor:pointer;border:none;border-radius:5px;background:#222;color:white;">Leave</button>
        </div>
    </div>
    <div id="exit-indicator" style="display:none;position:absolute;top:60%;left:50%;transform:translate(-50%,-50%);color:#7cff7c;font-family:Arial,sans-serif;font-size:18px;font-weight:bold;background:rgba(0,0,0,0.6);padding:8px 16px;border-radius:5px;z-index:140;pointer-events:none;"><span class='key-hint'>(E) </span>Exit</div>
    <div id="bed-indicator" style="display:none;position:absolute;top:65%;left:50%;transform:translate(-50%,-50%);color:#7cff7c;font-family:Arial,sans-serif;font-size:18px;font-weight:bold;background:rgba(0,0,0,0.6);padding:8px 16px;border-radius:5px;z-index:140;pointer-events:none;"><span class='key-hint'>(E) </span>Lay Down</div>
    <div id="combat-ui" style="display:none;position:absolute;top:20px;left:50%;transform:translateX(-50%);width:720px;background:rgba(0,0,0,0.8);border:2px solid #333;border-radius:10px;padding:20px;font-family:Arial,sans-serif;z-index:180;">
        <div style="color:#fff;font-size:18px;margin-bottom:10px;">Combat</div>
        <div style="display:flex;gap:12px;margin-bottom:12px;">
            <div style="flex:1;color:#9ef59e;">You: <span id="combat-player-hp"></span></div>
            <div style="flex:1;color:#ffb36b;">Remoro: <span id="combat-remoro-hp"></span></div>
            <div style="flex:1;color:#ff6b6b;">Owner: <span id="combat-enemy-hp"></span></div>
        </div>
        <div id="combat-log" style="height:120px;overflow:auto;background:rgba(0,0,0,0.5);padding:10px;border-radius:6px;color:#ddd;font-size:14px;margin-bottom:12px;"></div>
        <div id="combat-actions" style="display:flex;gap:10px;">
            <button id="combat-attack" style="flex:1;padding:10px;cursor:pointer;border:none;border-radius:5px;background:#2a5a2a;color:white;">Attack</button>
            <button id="combat-talk" style="flex:1;padding:10px;cursor:pointer;border:none;border-radius:5px;background:#3f3f3f;color:white;">Talk</button>
            <button id="combat-defend" style="flex:1;padding:10px;cursor:pointer;border:none;border-radius:5px;background:#2a2a5a;color:white;">Defend</button>
            <button id="combat-flee" style="flex:1;padding:10px;cursor:pointer;border:none;border-radius:5px;background:#5a2a2a;color:white;">Flee</button>
        </div>
    </div>
    <style>
        .dialog-option:hover {
            background: rgba(124, 255, 124, 0.2);
        }
    </style>
    
    <div id="mobile-controls">
        <div id="joystick-zone">
            <div id="joystick-base">
                <div id="joystick-stick"></div>
            </div>
        </div>
        <div id="mobile-buttons">
            <div class="mobile-btn" id="mobile-btn-camera" role="button" aria-label="Toggle camera mode" tabindex="0">CAM</div>
            <div class="mobile-btn" id="mobile-btn-shoot">FIRE</div>
            <div class="mobile-btn" id="mobile-btn-interact">ACT</div>
            <div class="mobile-btn" id="mobile-btn-weapon">SWAP</div>
        </div>
    </div>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    
    <script type="module">
        import * as THREE from 'three';
        import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
        import { MTLLoader } from 'three/addons/loaders/MTLLoader.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';

        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb); // Sky blue background
        scene.fog = new THREE.Fog(0x87ceeb, 100, 450); // Add fog to hide draw distance
        
        // Isometric camera setup
        let cameraZoom = 50; // Controls both height and distance
        const minZoom = 15;
        const maxZoom = 150;
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 500);
        
        // Player starting position
        const playerStartPos = new THREE.Vector3(-120.1, 0, 64.0);
        
        // Create local player model
        let localPlayerMesh = null;
        const playerMoveSpeed = 0.15;
        let targetPosition = null;
        const myPosition = new THREE.Vector3();
        
        // Raycaster for click-to-move
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        // Click indicator
        let clickIndicator = null;
        
        // Collision detection
        const collisionMeshes = [];
        const playerRadius = 0.4; // Player collision radius
        
        // Mobile detection
        const isMobile = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || (window.innerWidth <= 768);
        
        // Mobile joystick state
        const joystickState = { active: false, dx: 0, dy: 0, touchId: null };
        
        if (isMobile) {
            // Lock camera zoom on mobile
            cameraZoom = 40;
            
            // Prevent default touch behaviors on canvas (but allow scrolling in dialogs)
            document.addEventListener('touchmove', (e) => {
                if (e.target.closest('#combat-log') || e.target.closest('#house-dialog') || e.target.closest('#corpse-dialog') || e.target.closest('#combat-ui') || e.target.closest('#pole-dialog')) return;
                e.preventDefault();
            }, { passive: false });
            
            // --- Joystick ---
            const joystickZone = document.getElementById('joystick-zone');
            const joystickBase = document.getElementById('joystick-base');
            const joystickStick = document.getElementById('joystick-stick');
            const maxJoystickRadius = 45; // max stick travel in px
            
            joystickZone.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const touch = e.changedTouches[0];
                joystickState.active = true;
                joystickState.touchId = touch.identifier;
                updateJoystick(touch);
            }, { passive: false });
            
            joystickZone.addEventListener('touchmove', (e) => {
                e.preventDefault();
                for (const touch of e.changedTouches) {
                    if (touch.identifier === joystickState.touchId) {
                        updateJoystick(touch);
                    }
                }
            }, { passive: false });
            
            const endJoystick = (e) => {
                for (const touch of e.changedTouches) {
                    if (touch.identifier === joystickState.touchId) {
                        joystickState.active = false;
                        joystickState.dx = 0;
                        joystickState.dy = 0;
                        joystickState.touchId = null;
                        joystickStick.style.transform = 'translate(-50%, -50%)';
                    }
                }
            };
            joystickZone.addEventListener('touchend', endJoystick, { passive: false });
            joystickZone.addEventListener('touchcancel', endJoystick, { passive: false });
            
            function updateJoystick(touch) {
                const rect = joystickBase.getBoundingClientRect();
                const cx = rect.left + rect.width / 2;
                const cy = rect.top + rect.height / 2;
                let dx = touch.clientX - cx;
                let dy = touch.clientY - cy;
                const dist = Math.sqrt(dx * dx + dy * dy);
                if (dist > maxJoystickRadius) {
                    dx = (dx / dist) * maxJoystickRadius;
                    dy = (dy / dist) * maxJoystickRadius;
                }
                // Normalize to -1..1
                joystickState.dx = dx / maxJoystickRadius;
                joystickState.dy = dy / maxJoystickRadius;
                // Move stick visual
                joystickStick.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
            }
            
            // --- Action Buttons ---
            const shootBtn = document.getElementById('mobile-btn-shoot');
            const interactBtn = document.getElementById('mobile-btn-interact');
            const weaponBtn = document.getElementById('mobile-btn-weapon');
            const cameraBtn = document.getElementById('mobile-btn-camera');
            
            shootBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (!isPlayerDead && !isRagdoll) shoot();
            }, { passive: false });
            
            interactBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (isPlayerDead) return;
                if (inHouse && currentHouseIsKaj && typeof isNearBed === 'function' && isNearBed()) {
                    layInBed();
                } else if (inHouse && typeof isNearExit === 'function' && isNearExit()) {
                    exitHouse();
                } else if (typeof isFacingDeadBoy === 'function' && isFacingDeadBoy()) {
                    talkToDeadBoy();
                } else {
                    talkToRemoro();
                }
            }, { passive: false });
            
            weaponBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                currentWeaponIndex = (currentWeaponIndex + 1) % weapons.length;
                updateWeaponDisplay();
            }, { passive: false });
            
            cameraBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                toggleCameraMode();
            }, { passive: false });
            
            // Add keyboard support for camera button
            cameraBtn.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault(); // Prevent default scrolling for Space key
                    toggleCameraMode();
                    cameraBtn.blur(); // Remove focus after activation for better UX
                }
            });
            
        }
        
        // Renderer setup - optimized for performance
        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: 'high-performance' });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // Cap pixel ratio for performance
        document.body.appendChild(renderer.domElement);
        
        // Mobile touch swipe for first-person camera look
        if (isMobile) {
            const fpTouchState = { active: false, touchId: null, startX: 0, startY: 0 };
            const fpTouchSensitivity = 0.003; // radians per pixel
            
            renderer.domElement.addEventListener('touchstart', (e) => {
                // Only handle camera rotation in first-person mode
                if (!isFirstPersonMode) return;
                
                // Check if touch is not on joystick or buttons
                const touch = e.changedTouches[0];
                const target = e.target;
                if (target.closest('#joystick-zone') || target.closest('#mobile-buttons')) return;
                
                e.preventDefault();
                fpTouchState.active = true;
                fpTouchState.touchId = touch.identifier;
                fpTouchState.startX = touch.clientX;
                fpTouchState.startY = touch.clientY;
            }, { passive: false });
            
            renderer.domElement.addEventListener('touchmove', (e) => {
                if (!fpTouchState.active || !isFirstPersonMode) return;
                
                for (const touch of e.changedTouches) {
                    if (touch.identifier === fpTouchState.touchId) {
                        e.preventDefault();
                        const deltaX = touch.clientX - fpTouchState.startX;
                        const deltaY = touch.clientY - fpTouchState.startY;
                        
                        fpCameraYaw -= deltaX * fpTouchSensitivity;
                        fpCameraPitch -= deltaY * fpTouchSensitivity;
                        fpCameraPitch = Math.max(-fpMaxPitch, Math.min(fpMaxPitch, fpCameraPitch));
                        
                        // Normalize yaw to [-PI, PI] to prevent floating-point precision issues
                        while (fpCameraYaw > Math.PI) fpCameraYaw -= 2 * Math.PI;
                        while (fpCameraYaw < -Math.PI) fpCameraYaw += 2 * Math.PI;
                        
                        fpTouchState.startX = touch.clientX;
                        fpTouchState.startY = touch.clientY;
                        break;
                    }
                }
            }, { passive: false });
            
            const endFpTouch = (e) => {
                for (const touch of e.changedTouches) {
                    if (touch.identifier === fpTouchState.touchId) {
                        fpTouchState.active = false;
                        fpTouchState.touchId = null;
                    }
                }
            };
            renderer.domElement.addEventListener('touchend', endFpTouch, { passive: false });
            renderer.domElement.addEventListener('touchcancel', endFpTouch, { passive: false });
        }
        
        // CSS2D Renderer for nametags
        const labelRenderer = new CSS2DRenderer();
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
        labelRenderer.domElement.style.position = 'absolute';
        labelRenderer.domElement.style.top = '0';
        labelRenderer.domElement.style.pointerEvents = 'none';
        document.body.appendChild(labelRenderer.domElement);
        
        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(100, 200, 100);
        directionalLight.castShadow = true;
        scene.add(directionalLight);
        
        // Add a ground plane as fallback
        const groundGeometry = new THREE.PlaneGeometry(10000, 10000);
        const groundMaterial = new THREE.MeshLambertMaterial({ color: 0x3a5f0b });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -1;
        ground.name = 'ground';
        scene.add(ground);
        
        // Movement controls - click to move
        const moveSpeed = 0.15;
        let timeScale = 1;
        
        // Weapons system
        const weapons = [
            { id: 1, name: 'Pistol', damage: 25, fireRate: 400, range: 100, spread: 0.02, projectileSpeed: 2 },
            { id: 2, name: 'Rifle', damage: 35, fireRate: 150, range: 200, spread: 0.01, projectileSpeed: 3 },
            { id: 3, name: 'RPG', damage: 100, fireRate: 2000, range: 300, spread: 0, projectileSpeed: 0.8, explosive: true },
            { id: 4, name: 'Shotgun', damage: 15, fireRate: 800, range: 50, spread: 0.1, pellets: 8 }
        ];
        let currentWeaponIndex = 0;
        let lastFireTime = 0;
        const ragdollOverlay = document.getElementById('ragdoll-overlay');
        const ragdollText = document.getElementById('ragdoll-text');
        
        // Ragdoll state
        let isRagdoll = false;
        let ragdollTimer = null;
        
        // Projectiles for visual effects
        const projectiles = [];
        
        // First-person viewmodel system
        let viewmodelScene = null;
        let viewmodelCamera = null;
        let viewmodelArms = null;
        let viewmodelWeapons = [];
        let currentViewmodelWeapon = null;
        let viewmodelBobTime = 0;
        let viewmodelRecoil = 0;

        // Pedestrian NPC system
        const pedestrians = [];
        const pedestrianSpawnPoints = [
            { x: -120, z: 60 }, { x: -100, z: 70 }, { x: -130, z: 50 },
            { x: -520, z: -90 }, { x: -510, z: -100 }, { x: -530, z: -85 },
            { x: -300, z: 0 }, { x: -200, z: -50 }, { x: -150, z: 30 },
            { x: -400, z: -40 }, { x: -350, z: 20 }, { x: -250, z: 10 }
        ];
        const pedestrianWaypoints = [
            { x: -120, z: 80 }, { x: -140, z: 60 }, { x: -100, z: 50 },
            { x: -500, z: -80 }, { x: -540, z: -100 }, { x: -520, z: -70 },
            { x: -300, z: 20 }, { x: -280, z: -10 }, { x: -320, z: -20 },
            { x: -200, z: 0 }, { x: -180, z: -30 }, { x: -220, z: -60 },
            { x: -400, z: -20 }, { x: -420, z: -50 }, { x: -380, z: -30 }
        ];
        const pedestrianGunshotFleeRadius = 30;
        const pedestrianWalkSpeed = 0.08;
        const pedestrianRunSpeed = 0.25;
        const pedestrianCollisionRadius = 0.8;
        const pedestrianFallenHeight = 0.3;
        const pedestrianCenterHeight = 1.0; // Vertical offset from ground to center of pedestrian
        const pedestrianMinSpawnCount = 8; // Minimum number of pedestrians to spawn
        const pedestrianSpawnVariation = 5; // Random variation in number of pedestrians to spawn
        const pedestrianWaypointArrivalThreshold = 1; // Distance to waypoint considered "arrived"
        const cameraTogglePoleEventBufferDistance = 2; // Distance buffer (in game units) to prevent camera toggle conflicts near pole event

        // House interior and combat system
        let inHouse = false;
        let houseScene = null;
        let houseCamera = null;
        let houseFurniture = [];
        let houseNPC = null;
        let houseBounds = null;
        let lastOutsidePosition = new THREE.Vector3();
        let houseEntryCooldown = 0;
        let houseCombatActive = false;
        let playerDefending = false;
        let combatActionsDisabled = false;
        let currentHouseId = null;
        let currentHouseIsKaj = false;
        let kajHouseId = null;
        let kajHouseBedZone = null;
        const houseDefeated = new Set();
        let houseExitZone = null;
        let isPlayerDead = false;

        const houseDialogLines = [
            "What are you doing inside my house?",
            "Why are you here? You need to leave.",
            "This is private property. Explain yourself.",
            "Who let you in? Get out.",
            "You're not supposed to be here."
        ];

        const combatState = {
            player: { name: "You", maxHp: 120, hp: 120, atkMin: 12, atkMax: 20 },
            remoro: { name: "Remoro", maxHp: 100, hp: 100, atkMin: 10, atkMax: 18 },
            enemy: { name: "Owner", maxHp: 140, hp: 140, atkMin: 16, atkMax: 32 }
        };

        const houseDialogEl = document.getElementById('house-dialog');
        const houseDialogTextEl = document.getElementById('house-dialog-text');
        const houseLeaveBtn = document.getElementById('house-leave');
        const houseAttackBtn = document.getElementById('house-attack');
        const corpseDialogEl = document.getElementById('corpse-dialog');
        const corpseDialogTextEl = document.getElementById('corpse-dialog-text');
        const corpseLootBtn = document.getElementById('corpse-loot');
        const corpseEatBtn = document.getElementById('corpse-eat');
        const corpseRemoroBtn = document.getElementById('corpse-remoro');
        const corpseLeaveBtn = document.getElementById('corpse-leave');
        const exitIndicatorEl = document.getElementById('exit-indicator');
        const bedIndicatorEl = document.getElementById('bed-indicator');
        const combatUiEl = document.getElementById('combat-ui');
        const combatLogEl = document.getElementById('combat-log');
        const combatPlayerHpEl = document.getElementById('combat-player-hp');
        const combatRemoroHpEl = document.getElementById('combat-remoro-hp');
        const combatEnemyHpEl = document.getElementById('combat-enemy-hp');
        const combatAttackBtn = document.getElementById('combat-attack');
        const combatTalkBtn = document.getElementById('combat-talk');
        const combatDefendBtn = document.getElementById('combat-defend');
        const combatFleeBtn = document.getElementById('combat-flee');
        const statusHpEl = document.getElementById('player-hp');
        const statusCoinsEl = document.getElementById('kaj-coins');
        const deathScreenEl = document.getElementById('death-screen');
        const hurtFlashEl = document.getElementById('hurt-flash');
        let kajCoins = 0;
        const deathAudioFiles = [
            '/media/deathstuff/death_message.oga',
            '/media/deathstuff/death_message1.oga',
            '/media/deathstuff/death_message2.oga',
            '/media/deathstuff/death_message3.oga'
        ];
        const combatTalkLines = [
            'Fuck you',
            "I'm going to fahsion your skin into a handbag",
            "This is a nice place you've got here",
            'Im going to cut your dick off with a hacksaw'
        ];
        const remoroLootLines = [
            'Those are some fresh ass foams let me snatch them',
            'Gold Teeth! Payday',
            'These fingernails will look nice in my collection',
            'Free Clothes dont mind if I do',
            "Well its not like they'll be needing these versace handbags anyways"
        ];
        const remoroEatLines = [
            'Damn im hungry',
            'They lookin real tasty rn',
            "Looks like meats back on the menu",
            "Im not even going to sugarcoat it we're going to eat this person",
            'Pass the salt bro'
        ];

        function randomRange(min, max) {
            return min + Math.random() * (max - min);
        }

        function getHouseIdFromBox(box) {
            return `${box.min.x.toFixed(2)}|${box.min.z.toFixed(2)}|${box.max.x.toFixed(2)}|${box.max.z.toFixed(2)}`;
        }

        function createHouseLabel(text) {
            const div = document.createElement('div');
            div.textContent = text;
            div.style.cssText = 'color:#ffd966;font-family:Arial,sans-serif;font-size:16px;font-weight:bold;background:rgba(0,0,0,0.75);padding:4px 10px;border-radius:6px;white-space:nowrap;';
            return new CSS2DObject(div);
        }

        function setupKajHouseLabel() {
            if (collisionMeshes.length === 0) return;
            let best = null;
            let bestDist = Infinity;
            for (const mesh of collisionMeshes) {
                const box = mesh.userData.worldBox;
                const height = mesh.userData.height || 0;
                if (!box || height < 2.5) continue;
                const sizeX = box.max.x - box.min.x;
                const sizeZ = box.max.z - box.min.z;
                if (sizeX < 3 || sizeZ < 3) continue;
                const center = new THREE.Vector3(
                    (box.min.x + box.max.x) * 0.5,
                    (box.min.y + box.max.y) * 0.5,
                    (box.min.z + box.max.z) * 0.5
                );
                const dist = center.distanceTo(playerStartPos);
                if (dist < bestDist) {
                    bestDist = dist;
                    best = { box, center };
                }
            }
            if (!best) return;
            kajHouseId = getHouseIdFromBox(best.box);
            const anchor = new THREE.Object3D();
            anchor.position.set(best.center.x, best.box.max.y + 1.5, best.center.z);
            anchor.add(createHouseLabel('KAJ HOUSE'));
            scene.add(anchor);
        }

        function updateStatusHud() {
            if (statusHpEl) {
                statusHpEl.textContent = `${combatState.player.hp}`;
            }
            if (statusCoinsEl) {
                statusCoinsEl.textContent = `${kajCoins}`;
            }
        }

        function addKajCoins(amount) {
            kajCoins += amount;
            updateStatusHud();
        }

        function restoreHealth(amount) {
            combatState.player.hp = Math.min(combatState.player.maxHp, combatState.player.hp + amount);
            updateCombatUI();
            updateStatusHud();
        }

        function flashHurt() {
            if (!hurtFlashEl) return;
            hurtFlashEl.style.display = 'block';
            setTimeout(() => {
                hurtFlashEl.style.display = 'none';
            }, 120);
        }

        function triggerPlayerDeath(reason) {
            if (isPlayerDead) return;
            isPlayerDead = true;
            houseCombatActive = false;
            combatActionsDisabled = true;
            document.exitPointerLock();

            houseDialogEl.style.display = 'none';
            corpseDialogEl.style.display = 'none';
            combatUiEl.style.display = 'none';
            document.getElementById('crosshair').style.display = 'none';
            document.getElementById('weapon-display').style.display = 'none';
            exitIndicatorEl.style.display = 'none';
            talkIndicator.style.display = 'none';

            if (deathScreenEl) {
                deathScreenEl.style.display = 'block';
            }

            const audioSrc = deathAudioFiles[Math.floor(Math.random() * deathAudioFiles.length)];
            const deathAudio = new Audio(audioSrc);
            deathAudio.volume = 0.8;
            deathAudio.play().catch(() => {});

            setTimeout(() => {
                window.location.reload();
            }, 15000);
        }

        function createHouseInterior(isKajHouse = false) {
            houseScene = new THREE.Scene();
            houseScene.background = new THREE.Color(0x222222);
            houseCamera = camera;

            const light = new THREE.PointLight(0xffffff, 0.9);
            light.position.set(0, 3, 0);
            houseScene.add(light);

            const ambient = new THREE.AmbientLight(0xffffff, 0.4);
            houseScene.add(ambient);

            // Simple rectangular room
            const roomWidth = 12;
            const roomDepth = 10;
            const roomHeight = 4;
            houseBounds = {
                minX: -roomWidth / 2 + 0.5,
                maxX: roomWidth / 2 - 0.5,
                minZ: -roomDepth / 2 + 0.5,
                maxZ: roomDepth / 2 - 0.5
            };

            const floor = new THREE.Mesh(
                new THREE.PlaneGeometry(roomWidth, roomDepth),
                new THREE.MeshLambertMaterial({ color: 0x3a3a3a })
            );
            floor.rotation.x = -Math.PI / 2;
            houseScene.add(floor);

            const wallMat = new THREE.MeshLambertMaterial({ color: 0x444444 });
            const wallGeo = new THREE.BoxGeometry(roomWidth, roomHeight, 0.2);
            const wall1 = new THREE.Mesh(wallGeo, wallMat);
            wall1.position.set(0, roomHeight / 2, -roomDepth / 2);
            houseScene.add(wall1);
            const wall2 = new THREE.Mesh(wallGeo, wallMat);
            wall2.position.set(0, roomHeight / 2, roomDepth / 2);
            houseScene.add(wall2);

            const sideWallGeo = new THREE.BoxGeometry(0.2, roomHeight, roomDepth);
            const wall3 = new THREE.Mesh(sideWallGeo, wallMat);
            wall3.position.set(-roomWidth / 2, roomHeight / 2, 0);
            houseScene.add(wall3);
            const wall4 = new THREE.Mesh(sideWallGeo, wallMat);
            wall4.position.set(roomWidth / 2, roomHeight / 2, 0);
            houseScene.add(wall4);

            // Exit door
            const exitDoor = new THREE.Mesh(
                new THREE.BoxGeometry(2.2, 2.6, 0.15),
                new THREE.MeshLambertMaterial({ color: 0x2d2d2d })
            );
            exitDoor.position.set(0, 1.3, roomDepth / 2 - 0.08);
            houseScene.add(exitDoor);
            houseExitZone = {
                minX: -1.1,
                maxX: 1.1,
                minZ: roomDepth / 2 - 0.9,
                maxZ: roomDepth / 2 - 0.1
            };

            houseFurniture = [];
            houseNPC = null;
            kajHouseBedZone = null;

            if (isKajHouse) {
                const bedGroup = new THREE.Group();
                const frameMat = new THREE.MeshLambertMaterial({ color: 0x3a2a1a });
                const mattressMat = new THREE.MeshLambertMaterial({ color: 0xb0b0b0 });
                const pillowMat = new THREE.MeshLambertMaterial({ color: 0xe5e5e5 });

                const bedFrame = new THREE.Mesh(new THREE.BoxGeometry(3.0, 0.35, 1.6), frameMat);
                bedFrame.position.y = 0.18;
                bedGroup.add(bedFrame);

                const mattress = new THREE.Mesh(new THREE.BoxGeometry(2.8, 0.25, 1.4), mattressMat);
                mattress.position.y = 0.42;
                bedGroup.add(mattress);

                const pillow = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.15, 0.45), pillowMat);
                pillow.position.set(-0.8, 0.55, -0.45);
                bedGroup.add(pillow);

                bedGroup.position.set(-3.2, 0, -2.8);
                houseScene.add(bedGroup);
                houseFurniture.push({ mesh: bedGroup, halfW: 1.6, halfD: 0.9 });
                kajHouseBedZone = {
                    minX: bedGroup.position.x - 1.2,
                    maxX: bedGroup.position.x + 1.2,
                    minZ: bedGroup.position.z - 0.6,
                    maxZ: bedGroup.position.z + 0.6,
                    layPosition: new THREE.Vector3(bedGroup.position.x, 0, bedGroup.position.z + 0.2)
                };

                const cigPack = new THREE.Mesh(
                    new THREE.BoxGeometry(0.2, 0.05, 0.12),
                    new THREE.MeshLambertMaterial({ color: 0xf2f2f2 })
                );
                cigPack.position.set(-1.6, 0.03, -1.4);
                houseScene.add(cigPack);

                const gunPile = new THREE.Group();
                const gunMat = new THREE.MeshLambertMaterial({ color: 0x2b2b2b });
                for (let i = 0; i < 6; i++) {
                    const gun = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.08, 0.18), gunMat);
                    gun.position.set((Math.random() - 0.5) * 0.6, 0.05 + i * 0.03, (Math.random() - 0.5) * 0.6);
                    gun.rotation.y = Math.random() * Math.PI;
                    gunPile.add(gun);
                }
                gunPile.position.set(2.6, 0, -2.2);
                houseScene.add(gunPile);
                houseFurniture.push({ mesh: gunPile, halfW: 1.2, halfD: 1.2 });
                return;
            }

            // Random furniture
            const furnitureCount = 6 + Math.floor(Math.random() * 4);
            const furnitureMat = new THREE.MeshLambertMaterial({ color: 0x5a4a3a });
            for (let i = 0; i < furnitureCount; i++) {
                const w = randomRange(0.6, 1.6);
                const h = randomRange(0.5, 1.4);
                const d = randomRange(0.6, 1.4);
                const furniture = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), furnitureMat);
                furniture.position.set(
                    randomRange(houseBounds.minX + 1, houseBounds.maxX - 1),
                    h / 2,
                    randomRange(houseBounds.minZ + 1, houseBounds.maxZ - 1)
                );
                houseScene.add(furniture);
                houseFurniture.push({ mesh: furniture, halfW: w / 2 + 0.3, halfD: d / 2 + 0.3 });
            }

            // House NPC
            const npc = new THREE.Group();
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.5, 1.5, 0.3), new THREE.MeshLambertMaterial({ color: 0xaa4444 }));
            body.position.y = 0.75;
            npc.add(body);
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.35, 0.35), new THREE.MeshLambertMaterial({ color: 0xd4b896 }));
            head.position.y = 1.7;
            npc.add(head);
            npc.position.set(0, 0, -2.5);
            houseScene.add(npc);
            houseNPC = npc;
        }

        function checkHouseCollision(newPosition) {
            if (!houseBounds) return false;
            if (newPosition.x < houseBounds.minX || newPosition.x > houseBounds.maxX) return true;
            if (newPosition.z < houseBounds.minZ || newPosition.z > houseBounds.maxZ) return true;

            for (const item of houseFurniture) {
                const dx = Math.abs(newPosition.x - item.mesh.position.x);
                const dz = Math.abs(newPosition.z - item.mesh.position.z);
                if (dx < item.halfW && dz < item.halfD) return true;
            }
            return false;
        }

        function isNearExit() {
            if (!houseExitZone) return false;
            return (
                myPosition.x >= houseExitZone.minX && myPosition.x <= houseExitZone.maxX &&
                myPosition.z >= houseExitZone.minZ && myPosition.z <= houseExitZone.maxZ
            );
        }

        function updateExitIndicator() {
            if (!inHouse || houseCombatActive || houseDialogEl.style.display === 'block' || corpseDialogEl.style.display === 'block') {
                exitIndicatorEl.style.display = 'none';
                return;
            }
            exitIndicatorEl.style.display = isNearExit() ? 'block' : 'none';
        }

        function isNearBed() {
            if (!kajHouseBedZone) return false;
            return (
                myPosition.x >= kajHouseBedZone.minX && myPosition.x <= kajHouseBedZone.maxX &&
                myPosition.z >= kajHouseBedZone.minZ && myPosition.z <= kajHouseBedZone.maxZ
            );
        }

        function updateBedIndicator() {
            if (!bedIndicatorEl || !currentHouseIsKaj || !inHouse || houseCombatActive) {
                if (bedIndicatorEl) bedIndicatorEl.style.display = 'none';
                return;
            }
            bedIndicatorEl.style.display = isNearBed() ? 'block' : 'none';
        }

        function layInBed() {
            if (!kajHouseBedZone) return;
            myPosition.copy(kajHouseBedZone.layPosition);
            fpCameraPitch = 0.35;
        }

        function setHouseNpcCorpse() {
            if (!houseNPC) return;
            houseNPC.rotation.x = -Math.PI / 2;
            houseNPC.position.y = 0.3;
        }

        function startCameraPan(targetYaw, targetPitch) {
            cameraPanActive = true;
            cameraPanStartTime = performance.now();
            cameraPanStartYaw = fpCameraYaw;
            cameraPanStartPitch = fpCameraPitch;
            
            // Handle angle wrapping: ensure we take the shortest path
            let angleDiff = targetYaw - fpCameraYaw;
            while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
            while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
            
            cameraPanTargetYaw = fpCameraYaw + angleDiff;
            cameraPanTargetPitch = targetPitch;
        }

        function updateCameraPan(currentTime) {
            if (!cameraPanActive) return;
            
            const elapsed = currentTime - cameraPanStartTime;
            const t = Math.min(elapsed / cameraPanDuration, 1.0);
            
            // Use easeOutCubic for smooth deceleration
            const easeT = 1 - Math.pow(1 - t, 3);
            
            fpCameraYaw = cameraPanStartYaw + (cameraPanTargetYaw - cameraPanStartYaw) * easeT;
            fpCameraPitch = cameraPanStartPitch + (cameraPanTargetPitch - cameraPanStartPitch) * easeT;
            
            if (t >= 1.0) {
                cameraPanActive = false;
                // Normalize final yaw angle
                while (fpCameraYaw > Math.PI) fpCameraYaw -= 2 * Math.PI;
                while (fpCameraYaw < -Math.PI) fpCameraYaw += 2 * Math.PI;
            }
        }

        function enterHouse(defeatedAlready, isKajHouse = false) {
            if (inHouse || houseEntryCooldown > 0) return;
            inHouse = true;
            houseEntryCooldown = 120;
            lastOutsidePosition.copy(myPosition);
            currentHouseIsKaj = isKajHouse;

            // Reset and build a fresh interior
            createHouseInterior(isKajHouse);

            // Teleport inside
            myPosition.set(0, 0, 3.5);
            isFirstPersonMode = true;
            if (localPlayerMesh) localPlayerMesh.visible = false;
            if (!isMobile) renderer.domElement.requestPointerLock();
            
            // Set initial camera angle and start pan animation to NPC
            fpCameraYaw = Math.PI;
            fpCameraPitch = 0;
            
            // Pan camera to look at NPC (if not Kaj's house)
            if (!isKajHouse && houseNPC) {
                // Calculate angle to NPC from player position
                const toNpc = new THREE.Vector3().subVectors(houseNPC.position, myPosition);
                const targetYaw = Math.atan2(-toNpc.x, -toNpc.z);
                const distance = Math.sqrt(toNpc.x * toNpc.x + toNpc.z * toNpc.z);
                const targetPitch = Math.atan2(toNpc.y + 0.7, distance); // +0.7 to aim at NPC head height
                startCameraPan(targetYaw, targetPitch);
            }

            // Show UI
            document.getElementById('crosshair').style.display = isMobile ? 'none' : 'block';
            document.getElementById('weapon-display').style.display = 'block';
            updateWeaponDisplay();

            // Show dialog
            houseCombatActive = false;
            houseDialogEl.style.display = 'none';
            corpseDialogEl.style.display = 'none';
            corpseLootBtn.disabled = false;
            corpseEatBtn.disabled = false;
            corpseRemoroBtn.disabled = false;
            if (isKajHouse) {
                houseAttackBtn.disabled = true;
                updateExitIndicator();
                updateBedIndicator();
                return;
            }
            if (defeatedAlready) {
                setHouseNpcCorpse();
                corpseDialogTextEl.textContent = 'You\'ve already killed this person. You can\'t kill them again, you fucking lunatic.';
                corpseDialogEl.style.display = 'block';
                houseAttackBtn.disabled = true;
            } else {
                const line = houseDialogLines[Math.floor(Math.random() * houseDialogLines.length)];
                houseDialogTextEl.textContent = line;
                houseDialogEl.style.display = 'block';
                houseAttackBtn.disabled = false;
            }
            updateExitIndicator();
        }

        function exitHouse() {
            inHouse = false;
            houseCombatActive = false;
            houseScene = null;
            houseFurniture = [];
            houseNPC = null;
            houseBounds = null;
            houseExitZone = null;
            kajHouseBedZone = null;
            myPosition.copy(lastOutsidePosition);
            if (localPlayerMesh) localPlayerMesh.visible = true;
            isFirstPersonMode = false;
            targetPosition = null;
            if (!isMobile) document.exitPointerLock();
            houseDialogEl.style.display = 'none';
            combatUiEl.style.display = 'none';
            corpseDialogEl.style.display = 'none';
            document.getElementById('crosshair').style.display = 'none';
            document.getElementById('weapon-display').style.display = 'none';
            exitIndicatorEl.style.display = 'none';
            bedIndicatorEl.style.display = 'none';
            houseEntryCooldown = 240;
            currentHouseId = null;
            currentHouseIsKaj = false;
        }

        function checkHouseEntry() {
            if (inHouse || houseEntryCooldown > 0 || isFirstPersonMode) return;
            const entryDistance = 2.2;
            for (const mesh of collisionMeshes) {
                const box = mesh.userData.worldBox;
                const height = mesh.userData.height || 0;
                if (!box || height < 2.5) continue;
                if (
                    myPosition.x > box.min.x - entryDistance && myPosition.x < box.max.x + entryDistance &&
                    myPosition.z > box.min.z - entryDistance && myPosition.z < box.max.z + entryDistance
                ) {
                    const houseId = getHouseIdFromBox(box);
                    currentHouseId = houseId;
                    enterHouse(houseDefeated.has(houseId), houseId === kajHouseId);
                    break;
                }
            }
        }

        function updateHouseMovement() {
            if (!isFirstPersonMode) return;

            if (houseCombatActive) {
                camera.position.copy(myPosition).add(new THREE.Vector3(0, 1.7, 0));
                camera.rotation.order = 'YXZ';
                camera.rotation.y = fpCameraYaw;
                camera.rotation.x = fpCameraPitch;
                camera.rotation.z = 0;
                updateExitIndicator();
                updateBedIndicator();
                return;
            }

            const forward = new THREE.Vector3(
                -Math.sin(fpCameraYaw),
                0,
                -Math.cos(fpCameraYaw)
            );
            const right = new THREE.Vector3(
                Math.cos(fpCameraYaw),
                0,
                -Math.sin(fpCameraYaw)
            );

            const newPos = myPosition.clone();
            
            // Mobile joystick drives first-person movement inside houses
            if (isMobile && joystickState.active && (Math.abs(joystickState.dx) > 0.1 || Math.abs(joystickState.dy) > 0.1)) {
                // Joystick maps relative to camera facing direction
                newPos.add(forward.clone().multiplyScalar(-joystickState.dy * fpMoveSpeed * 1.5));
                newPos.add(right.clone().multiplyScalar(joystickState.dx * fpMoveSpeed * 1.5));
            } else {
                if (fpKeys.w) newPos.add(forward.clone().multiplyScalar(fpMoveSpeed));
                if (fpKeys.s) newPos.add(forward.clone().multiplyScalar(-fpMoveSpeed));
                if (fpKeys.a) newPos.add(right.clone().multiplyScalar(-fpMoveSpeed));
                if (fpKeys.d) newPos.add(right.clone().multiplyScalar(fpMoveSpeed));
            }

            if (!checkHouseCollision(newPos)) {
                myPosition.copy(newPos);
            }

            camera.position.copy(myPosition).add(new THREE.Vector3(0, 1.7, 0));
            camera.rotation.order = 'YXZ';
            camera.rotation.y = fpCameraYaw;
            camera.rotation.x = fpCameraPitch;
            camera.rotation.z = 0;

            updateExitIndicator();
            updateBedIndicator();
            if (isNearExit() && houseDialogEl.style.display !== 'block' && corpseDialogEl.style.display !== 'block') {
                exitHouse();
            }
        }

        function logCombat(text) {
            const line = document.createElement('div');
            line.textContent = text;
            combatLogEl.appendChild(line);
            combatLogEl.scrollTop = combatLogEl.scrollHeight;
        }

        function playCombatAttackSound(isPlayer) {
            if (isPlayer) {
                const weapon = weapons[currentWeaponIndex];
                if (!weapon.explosive) {
                    if (weapon.name === 'Pistol') {
                        playSound(pistolFireSound);
                    } else if (weapon.name === 'Rifle' || weapon.name === 'Shotgun') {
                        playSound(smgFireSound);
                    }
                } else {
                    playSound(explosionSound);
                }
            } else {
                playSound(smgFireSound);
            }
        }

        function animateNpcHit() {
            if (!houseNPC) return;
            const start = performance.now();
            const duration = 140;
            const originalPos = houseNPC.position.clone();
            const flashMeshes = [];
            houseNPC.traverse((child) => {
                if (child.isMesh) {
                    flashMeshes.push({ mesh: child, color: child.material.color.getHex() });
                    child.material.color.setHex(0xff6666);
                }
            });

            const animate = () => {
                const t = (performance.now() - start) / duration;
                if (t < 1) {
                    houseNPC.position.x = originalPos.x + (Math.random() - 0.5) * 0.08;
                    houseNPC.position.z = originalPos.z + (Math.random() - 0.5) * 0.08;
                    requestAnimationFrame(animate);
                } else {
                    houseNPC.position.copy(originalPos);
                    flashMeshes.forEach((item) => item.mesh.material.color.setHex(item.color));
                }
            };
            animate();
        }

        function updateCombatUI() {
            combatPlayerHpEl.textContent = `${combatState.player.hp}/${combatState.player.maxHp}`;
            combatRemoroHpEl.textContent = `${combatState.remoro.hp}/${combatState.remoro.maxHp}`;
            combatEnemyHpEl.textContent = `${combatState.enemy.hp}/${combatState.enemy.maxHp}`;
            updateStatusHud();
        }

        function startCombat() {
            houseCombatActive = true;
            combatUiEl.style.display = 'block';
            houseDialogEl.style.display = 'none';
            corpseDialogEl.style.display = 'none';
            combatLogEl.innerHTML = '';
            combatState.player.hp = combatState.player.maxHp;
            combatState.remoro.hp = combatState.remoro.maxHp;
            combatState.enemy.hp = combatState.enemy.maxHp;
            playerDefending = false;
            combatActionsDisabled = false;
            combatAttackBtn.disabled = false;
            combatTalkBtn.disabled = false;
            combatDefendBtn.disabled = false;
            combatFleeBtn.disabled = false;
            updateCombatUI();
            logCombat('Combat begins.');
        }

        function endCombat(victory) {
            houseCombatActive = false;
            combatActionsDisabled = true;
            combatAttackBtn.disabled = true;
            combatTalkBtn.disabled = true;
            combatDefendBtn.disabled = true;
            combatFleeBtn.disabled = true;
            logCombat(victory ? 'You won the fight.' : 'You were defeated.');
            if (victory && houseNPC) {
                setHouseNpcCorpse();
            }
            setTimeout(() => {
                combatUiEl.style.display = 'none';
                if (victory) {
                    if (currentHouseId) {
                        houseDefeated.add(currentHouseId);
                    }
                    corpseDialogTextEl.textContent = 'The owner is dead. What do you do?';
                    corpseDialogEl.style.display = 'block';
                    updateExitIndicator();
                } else {
                    exitHouse();
                }
            }, 1200);
        }

        function rollDamage(min, max) {
            return Math.floor(randomRange(min, max + 1));
        }

        function enemyAttack() {
            const dmg = rollDamage(combatState.enemy.atkMin, combatState.enemy.atkMax);
            const finalDmg = playerDefending ? Math.floor(dmg * 0.5) : dmg;
            let v = Math.floor(Math.random() * 2);
            if(v == 1){
                combatState.player.hp = Math.max(0, combatState.player.hp - finalDmg);
                playerDefending = false;
                flashHurt();
                logCombat(`Owner hits you for ${finalDmg}.`);
                updateCombatUI();
            }
            else{
                combatState.remoro.hp = Math.max(0, combatState.remoro.hp - finalDmg);
                logCombat(`Owner hits remoro for ${finalDmg}.`);
                updateCombatUI();
            }
            
            
            if (combatState.player.hp <= 0) {
                triggerPlayerDeath('combat');
            }
        }

        function remoroAttack() {
            const dmg = rollDamage(combatState.remoro.atkMin, combatState.remoro.atkMax);
            combatState.enemy.hp = Math.max(0, combatState.enemy.hp - dmg);
            playCombatAttackSound(false);
            animateNpcHit();
            logCombat(`Remoro hits Owner for ${dmg}.`);
            updateCombatUI();
        }

        function playerAttack() {
            const dmg = rollDamage(combatState.player.atkMin, combatState.player.atkMax);
            combatState.enemy.hp = Math.max(0, combatState.enemy.hp - dmg);
            playCombatAttackSound(true);
            animateNpcHit();
            logCombat(`You hit Owner for ${dmg}.`);
            updateCombatUI();
        }

        function handlePlayerAction(action) {
            if (!houseCombatActive) return;
            if (combatActionsDisabled) return;
            if (combatState.player.hp <= 0 || combatState.enemy.hp <= 0) return;

            combatActionsDisabled = true;
            combatAttackBtn.disabled = true;
            combatTalkBtn.disabled = true;
            combatDefendBtn.disabled = true;
            combatFleeBtn.disabled = true;

            if (action === 'attack') {
                playerAttack();
            } else if (action === 'talk') {
                const line = combatTalkLines[Math.floor(Math.random() * combatTalkLines.length)];
                logCombat(`You: ${line}`);
            } else if (action === 'defend') {
                playerDefending = true;
                logCombat('You brace for impact.');
            } else if (action === 'flee') {
                logCombat('You flee the house.');
                endCombat(false);
                return;
            }

            if (combatState.enemy.hp <= 0) {
                endCombat(true);
                return;
            }

            setTimeout(() => {
                remoroAttack();
                if (combatState.enemy.hp <= 0) {
                    endCombat(true);
                    return;
                }

                setTimeout(() => {
                    enemyAttack();
                    if (combatState.player.hp <= 0) return;
                    if (houseCombatActive) {
                        combatActionsDisabled = false;
                        combatAttackBtn.disabled = false;
                        combatTalkBtn.disabled = false;
                        combatDefendBtn.disabled = false;
                        combatFleeBtn.disabled = false;
                    }
                }, 450);
            }, 350);
        }
        
        // Create viewmodel scene (rendered on top of main scene)
        function initViewmodelScene() {
            viewmodelScene = new THREE.Scene();
            viewmodelCamera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 10);
            
            // Add lighting to viewmodel scene
            const vmAmbient = new THREE.AmbientLight(0xffffff, 0.8);
            viewmodelScene.add(vmAmbient);
            const vmDirectional = new THREE.DirectionalLight(0xffffff, 0.6);
            vmDirectional.position.set(1, 1, 1);
            viewmodelScene.add(vmDirectional);
            
            // Create arms
            viewmodelArms = createViewmodelArms();
            viewmodelScene.add(viewmodelArms);
            
            // Create weapon models
            viewmodelWeapons = [
                createPistolViewmodel(),
                createRifleViewmodel(),
                createRPGViewmodel(),
                createShotgunViewmodel()
            ];
            
            // Add all weapons to scene but hide them initially
            viewmodelWeapons.forEach((weapon, index) => {
                weapon.visible = index === 0;
                viewmodelScene.add(weapon);
            });
            currentViewmodelWeapon = viewmodelWeapons[0];
        }
        
        // Create arm models
        function createViewmodelArms() {
            const group = new THREE.Group();
            const skinColor = 0xffcc99;
            const sleeveColor = 0x2d5a27; // Green sleeve
            
            // Right arm
            const rightArm = new THREE.Group();
            
            // Upper arm (sleeve)
            const upperArmGeo = new THREE.BoxGeometry(0.08, 0.2, 0.08);
            const sleeveMat = new THREE.MeshLambertMaterial({ color: sleeveColor });
            const upperArm = new THREE.Mesh(upperArmGeo, sleeveMat);
            upperArm.position.set(0, -0.1, 0);
            rightArm.add(upperArm);
            
            // Forearm (skin)
            const forearmGeo = new THREE.BoxGeometry(0.07, 0.18, 0.07);
            const skinMat = new THREE.MeshLambertMaterial({ color: skinColor });
            const forearm = new THREE.Mesh(forearmGeo, skinMat);
            forearm.position.set(0, -0.25, 0);
            rightArm.add(forearm);
            
            // Hand
            const handGeo = new THREE.BoxGeometry(0.08, 0.08, 0.06);
            const hand = new THREE.Mesh(handGeo, skinMat);
            hand.position.set(0, -0.38, 0);
            rightArm.add(hand);
            
            rightArm.position.set(0.15, -0.18, -0.35);
            rightArm.rotation.x = Math.PI / 2.2;
            group.add(rightArm);
            
            // Left arm (supporting)
            const leftArm = new THREE.Group();
            
            const leftUpperArm = new THREE.Mesh(upperArmGeo, sleeveMat);
            leftUpperArm.position.set(0, -0.1, 0);
            leftArm.add(leftUpperArm);
            
            const leftForearm = new THREE.Mesh(forearmGeo, skinMat);
            leftForearm.position.set(0, -0.25, 0);
            leftArm.add(leftForearm);
            
            const leftHand = new THREE.Mesh(handGeo, skinMat);
            leftHand.position.set(0, -0.38, 0);
            leftArm.add(leftHand);
            
            leftArm.position.set(-0.1, -0.22, -0.42);
            leftArm.rotation.x = Math.PI / 2;
            leftArm.rotation.z = 0.3;
            group.add(leftArm);
            
            return group;
        }
        
        // Create pistol viewmodel
        function createPistolViewmodel() {
            const group = new THREE.Group();
            const metalColor = 0x333333;
            const metalMat = new THREE.MeshLambertMaterial({ color: metalColor });
            const gripMat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
            
            // Slide (top part)
            const slideGeo = new THREE.BoxGeometry(0.04, 0.05, 0.18);
            const slide = new THREE.Mesh(slideGeo, metalMat);
            slide.position.set(0, 0.025, 0);
            group.add(slide);
            
            // Frame/grip
            const gripGeo = new THREE.BoxGeometry(0.035, 0.12, 0.08);
            const grip = new THREE.Mesh(gripGeo, gripMat);
            grip.position.set(0, -0.05, 0.04);
            grip.rotation.x = -0.2;
            group.add(grip);
            
            // Barrel
            const barrelGeo = new THREE.CylinderGeometry(0.008, 0.008, 0.08, 8);
            const barrel = new THREE.Mesh(barrelGeo, metalMat);
            barrel.rotation.x = Math.PI / 2;
            barrel.position.set(0, 0.02, -0.12);
            group.add(barrel);
            
            // Trigger guard
            const guardGeo = new THREE.TorusGeometry(0.02, 0.005, 8, 8, Math.PI);
            const guard = new THREE.Mesh(guardGeo, metalMat);
            guard.position.set(0, -0.02, 0.02);
            guard.rotation.y = Math.PI / 2;
            group.add(guard);
            
            // Adjusted position to align with arms better
            group.position.set(0.05, -0.25, -0.45);
            group.rotation.y = -0.05;
            return group;
        }
        
        // Create rifle viewmodel
        function createRifleViewmodel() {
            const group = new THREE.Group();
            const metalMat = new THREE.MeshLambertMaterial({ color: 0x2a2a2a });
            const woodMat = new THREE.MeshLambertMaterial({ color: 0x4a3728 });
            
            // Receiver
            const receiverGeo = new THREE.BoxGeometry(0.06, 0.08, 0.35);
            const receiver = new THREE.Mesh(receiverGeo, metalMat);
            group.add(receiver);
            
            // Barrel
            const barrelGeo = new THREE.CylinderGeometry(0.015, 0.015, 0.4, 8);
            const barrel = new THREE.Mesh(barrelGeo, metalMat);
            barrel.rotation.x = Math.PI / 2;
            barrel.position.set(0, 0.01, -0.35);
            group.add(barrel);
            
            // Stock
            const stockGeo = new THREE.BoxGeometry(0.05, 0.1, 0.2);
            const stock = new THREE.Mesh(stockGeo, woodMat);
            stock.position.set(0, -0.02, 0.25);
            group.add(stock);
            
            // Magazine
            const magGeo = new THREE.BoxGeometry(0.04, 0.15, 0.06);
            const mag = new THREE.Mesh(magGeo, metalMat);
            mag.position.set(0, -0.1, 0.05);
            group.add(mag);
            
            // Scope rail
            const railGeo = new THREE.BoxGeometry(0.03, 0.02, 0.15);
            const rail = new THREE.Mesh(railGeo, metalMat);
            rail.position.set(0, 0.05, -0.05);
            group.add(rail);
            
            // Adjusted position to align with arms better
            group.position.set(0, -0.25, -0.5);
            group.rotation.y = -0.03;
            return group;
        }
        
        // Create RPG viewmodel
        function createRPGViewmodel() {
            const group = new THREE.Group();
            const tubeMat = new THREE.MeshLambertMaterial({ color: 0x3d5c3d });
            const metalMat = new THREE.MeshLambertMaterial({ color: 0x444444 });
            const warheadMat = new THREE.MeshLambertMaterial({ color: 0x556b2f });
            
            // Main tube
            const tubeGeo = new THREE.CylinderGeometry(0.05, 0.05, 0.7, 12);
            const tube = new THREE.Mesh(tubeGeo, tubeMat);
            tube.rotation.x = Math.PI / 2;
            group.add(tube);
            
            // Front sight
            const sightGeo = new THREE.BoxGeometry(0.02, 0.06, 0.02);
            const sight = new THREE.Mesh(sightGeo, metalMat);
            sight.position.set(0, 0.07, -0.25);
            group.add(sight);
            
            // Warhead (sticking out front)
            const warheadGeo = new THREE.ConeGeometry(0.04, 0.15, 8);
            const warhead = new THREE.Mesh(warheadGeo, warheadMat);
            warhead.rotation.x = -Math.PI / 2;
            warhead.position.set(0, 0, -0.45);
            group.add(warhead);
            
            // Grip
            const gripGeo = new THREE.BoxGeometry(0.04, 0.12, 0.06);
            const grip = new THREE.Mesh(gripGeo, metalMat);
            grip.position.set(0, -0.08, 0.1);
            group.add(grip);
            
            // Adjusted position to align with arms better
            group.position.set(0, -0.22, -0.45);
            return group;
        }
        
        // Create shotgun viewmodel
        function createShotgunViewmodel() {
            const group = new THREE.Group();
            const metalMat = new THREE.MeshLambertMaterial({ color: 0x1a1a1a });
            const woodMat = new THREE.MeshLambertMaterial({ color: 0x5c4033 });
            
            // Barrel (double barrel)
            const barrelGeo = new THREE.CylinderGeometry(0.02, 0.02, 0.5, 8);
            const barrel1 = new THREE.Mesh(barrelGeo, metalMat);
            barrel1.rotation.x = Math.PI / 2;
            barrel1.position.set(0.015, 0.02, -0.1);
            group.add(barrel1);
            
            const barrel2 = new THREE.Mesh(barrelGeo, metalMat);
            barrel2.rotation.x = Math.PI / 2;
            barrel2.position.set(-0.015, 0.02, -0.1);
            group.add(barrel2);
            
            // Receiver
            const receiverGeo = new THREE.BoxGeometry(0.07, 0.08, 0.12);
            const receiver = new THREE.Mesh(receiverGeo, metalMat);
            receiver.position.set(0, 0, 0.15);
            group.add(receiver);
            
            // Stock
            const stockGeo = new THREE.BoxGeometry(0.06, 0.1, 0.25);
            const stock = new THREE.Mesh(stockGeo, woodMat);
            stock.position.set(0, -0.02, 0.32);
            group.add(stock);
            
            // Forend (pump grip area)
            const forendGeo = new THREE.BoxGeometry(0.06, 0.05, 0.12);
            const forend = new THREE.Mesh(forendGeo, woodMat);
            forend.position.set(0, -0.02, -0.05);
            group.add(forend);
            
            // Adjusted position to align with arms better
            group.position.set(0, -0.25, -0.5);
            group.rotation.y = -0.03;
            return group;
        }
        
        // Update viewmodel (called every frame when in first person)
        function updateViewmodel() {
            if (!isFirstPersonMode || !viewmodelScene) return;
            
            // Switch weapon models if needed
            if (currentViewmodelWeapon !== viewmodelWeapons[currentWeaponIndex]) {
                if (currentViewmodelWeapon) currentViewmodelWeapon.visible = false;
                currentViewmodelWeapon = viewmodelWeapons[currentWeaponIndex];
                currentViewmodelWeapon.visible = true;
            }
            
            // Bob animation based on movement
            const isMoving = fpKeys.w || fpKeys.a || fpKeys.s || fpKeys.d;
            if (isMoving) {
                viewmodelBobTime += 0.15;
            }
            
            const bobX = Math.sin(viewmodelBobTime) * 0.01;
            const bobY = Math.abs(Math.cos(viewmodelBobTime)) * 0.008;
            
            // Apply bob to arms and weapon
            if (viewmodelArms) {
                viewmodelArms.position.x = bobX;
                viewmodelArms.position.y = bobY - 0.1;
            }
            if (currentViewmodelWeapon) {
                const basePos = currentViewmodelWeapon.userData.basePosition || currentViewmodelWeapon.position.clone();
                if (!currentViewmodelWeapon.userData.basePosition) {
                    currentViewmodelWeapon.userData.basePosition = basePos.clone();
                }
                currentViewmodelWeapon.position.x = basePos.x + bobX;
                currentViewmodelWeapon.position.y = basePos.y + bobY - viewmodelRecoil * 0.1;
                currentViewmodelWeapon.position.z = basePos.z + viewmodelRecoil * 0.05;
                currentViewmodelWeapon.rotation.x = viewmodelRecoil * 0.3;
            }
            
            // Decay recoil
            viewmodelRecoil *= 0.85;
            if (viewmodelRecoil < 0.01) viewmodelRecoil = 0;
        }
        
        // Trigger viewmodel recoil animation
        function triggerViewmodelRecoil() {
            const weapon = weapons[currentWeaponIndex];
            // Different recoil amounts per weapon
            if (weapon.name === 'Pistol') viewmodelRecoil = 0.3;
            else if (weapon.name === 'Rifle') viewmodelRecoil = 0.15;
            else if (weapon.name === 'RPG') viewmodelRecoil = 0.8;
            else if (weapon.name === 'Shotgun') viewmodelRecoil = 0.6;
        }
        
        // Create click indicator (circle on ground where player clicks)
        function createClickIndicator() {
            const geometry = new THREE.RingGeometry(0.3, 0.5, 32);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0x00ff00, 
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.7
            });
            const indicator = new THREE.Mesh(geometry, material);
            indicator.rotation.x = -Math.PI / 2;
            indicator.visible = false;
            scene.add(indicator);
            return indicator;
        }
        
        // Create local player model
        // Create tie-dye canvas texture
        function createTieDyeTexture() {
            const size = 128;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            
            // Base color
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, size, size);
            
            // Tie-dye spiral colors
            const colors = [
                [255, 40, 40],   // red
                [255, 165, 0],   // orange
                [255, 255, 40],  // yellow
                [40, 200, 40],   // green
                [40, 120, 255],  // blue
                [150, 40, 200],  // purple
                [255, 80, 180],  // pink
            ];
            
            const cx = size / 2, cy = size / 2;
            const imageData = ctx.getImageData(0, 0, size, size);
            const data = imageData.data;
            
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    const dx = x - cx, dy = y - cy;
                    const angle = Math.atan2(dy, dx) + Math.PI;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const spiral = (angle / (2 * Math.PI) + dist / 30) % 1;
                    const ci = Math.floor(spiral * colors.length);
                    const c = colors[ci % colors.length];
                    // Add some noise for realism
                    const noise = (Math.random() - 0.5) * 30;
                    const idx = (y * size + x) * 4;
                    data[idx] = Math.max(0, Math.min(255, c[0] + noise));
                    data[idx+1] = Math.max(0, Math.min(255, c[1] + noise));
                    data[idx+2] = Math.max(0, Math.min(255, c[2] + noise));
                    data[idx+3] = 255;
                }
            }
            ctx.putImageData(imageData, 0, 0);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            return texture;
        }
        
        function createLocalPlayer() {
            const group = new THREE.Group();
            
            // Body (rectangle) - Tie-dye shirt
            const bodyGeometry = new THREE.BoxGeometry(0.5, 1.5, 0.3);
            const tieDyeTex = createTieDyeTexture();
            const bodyMaterial = new THREE.MeshLambertMaterial({ map: tieDyeTex });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.75;
            group.add(body);
            
            // Head
            const headGeometry = new THREE.BoxGeometry(0.35, 0.35, 0.35);
            const headMaterial = new THREE.MeshLambertMaterial({ color: 0xffcc99 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.7;
            group.add(head);
            
            return group;
        }
        
        // Create Remoro companion
        let remoroMesh = null;
        const remoroFollowDistance = 2.5; // How far behind Remoro follows
        const remoroMoveSpeed = 0.12;
        
        function createRemoro() {
            const group = new THREE.Group();
            
            // Body (rectangle) - Orange
            const bodyGeometry = new THREE.BoxGeometry(0.5, 1.5, 0.3);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0xff8c00 }); // Orange body
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.75;
            group.add(body);
            
            // Head - African American skin tone
            const headGeometry = new THREE.BoxGeometry(0.35, 0.35, 0.35);
            const headMaterial = new THREE.MeshLambertMaterial({ color: 0x8d5524 }); // African American skin tone
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.7;
            group.add(head);
            
            // Add nametag
            const label = createNametag('Remoro');
            label.position.set(0, 2.8, 0); // Position higher above head
            group.add(label);
            
            return group;
        }
        
        // Update Remoro to follow player
        function updateRemoro() {
            if (!remoroMesh || !localPlayerMesh) return;
            
            const remoroPos = remoroMesh.position;
            const targetPos = myPosition.clone();
            
            // Calculate direction from Remoro to player
            const direction = targetPos.clone().sub(remoroPos);
            const distance = direction.length();
            
            // Only move if farther than follow distance
            if (distance > remoroFollowDistance) {
                direction.normalize();
                const moveAmount = Math.min(remoroMoveSpeed * timeScale, distance - remoroFollowDistance + 0.5);
                remoroPos.add(direction.clone().multiplyScalar(moveAmount));
                
                // Rotate Remoro to face movement direction
                const remoroYaw = Math.atan2(-direction.x, -direction.z);
                remoroMesh.rotation.y = remoroYaw;
            }
        }

        // Pedestrian NPC functions
        function createPedestrian(position) {
            const group = new THREE.Group();
            
            // Random appearance variations
            const bodyColors = [0x2d5a27, 0x3a4a8a, 0x8a3a3a, 0x4a4a4a, 0x5a3a2a];
            const skinColors = [0xffcc99, 0xf4c2a0, 0xe0ac69, 0x8d5524, 0xc68642];
            
            const bodyColor = bodyColors[Math.floor(Math.random() * bodyColors.length)];
            const skinColor = skinColors[Math.floor(Math.random() * skinColors.length)];
            
            // Body
            const bodyGeometry = new THREE.BoxGeometry(0.5, 1.5, 0.3);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: bodyColor });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.75;
            group.add(body);
            
            // Head
            const headGeometry = new THREE.BoxGeometry(0.35, 0.35, 0.35);
            const headMaterial = new THREE.MeshLambertMaterial({ color: skinColor });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.7;
            group.add(head);
            
            group.position.copy(position);
            scene.add(group);
            
            // Random initial target waypoint
            const targetWaypoint = pedestrianWaypoints[Math.floor(Math.random() * pedestrianWaypoints.length)];
            
            return {
                mesh: group,
                target: new THREE.Vector3(targetWaypoint.x, 0, targetWaypoint.z),
                state: 'walking', // 'walking', 'fleeing', 'dead'
                speed: pedestrianWalkSpeed,
                fleeTarget: null,
                isDead: false,
                deathTimer: 0
            };
        }

        function spawnPedestrians() {
            // Spawn pedestrians at random spawn points
            const numPedestrians = pedestrianMinSpawnCount + Math.floor(Math.random() * pedestrianSpawnVariation);
            for (let i = 0; i < numPedestrians; i++) {
                const spawnPoint = pedestrianSpawnPoints[Math.floor(Math.random() * pedestrianSpawnPoints.length)];
                const position = new THREE.Vector3(spawnPoint.x, 0, spawnPoint.z);
                const pedestrian = createPedestrian(position);
                pedestrians.push(pedestrian);
            }
        }

        function updatePedestrians() {
            for (let i = pedestrians.length - 1; i >= 0; i--) {
                const ped = pedestrians[i];
                
                if (ped.isDead) {
                    // Dead pedestrians don't move
                    continue;
                }
                
                const pedPos = ped.mesh.position;
                const targetPos = ped.target;
                
                // Calculate direction to target
                const direction = targetPos.clone().sub(pedPos);
                const distance = direction.length();
                
                // If reached target, choose new waypoint
                if (distance < pedestrianWaypointArrivalThreshold) {
                    if (ped.state === 'fleeing' && ped.fleeTarget) {
                        // Reached house, disappear
                        scene.remove(ped.mesh);
                        pedestrians.splice(i, 1);
                        continue;
                    } else {
                        // Choose new random waypoint
                        const newWaypoint = pedestrianWaypoints[Math.floor(Math.random() * pedestrianWaypoints.length)];
                        ped.target.set(newWaypoint.x, 0, newWaypoint.z);
                        continue;
                    }
                }
                
                // Move towards target
                direction.normalize();
                const moveAmount = Math.min(ped.speed * timeScale, distance);
                pedPos.add(direction.clone().multiplyScalar(moveAmount));
                
                // Rotate to face movement direction
                const yaw = Math.atan2(-direction.x, -direction.z);
                ped.mesh.rotation.y = yaw;
            }
        }

        function makeNearbyPedestriansFlee(gunshotPosition) {
            for (const ped of pedestrians) {
                if (ped.isDead || ped.state === 'fleeing') continue;
                
                const distance = ped.mesh.position.distanceTo(gunshotPosition);
                
                if (distance < pedestrianGunshotFleeRadius) {
                    // Find nearest house (use waypoints as approximate house locations)
                    let nearestHouse = pedestrianWaypoints[0];
                    let nearestDist = Infinity;
                    
                    for (const waypoint of pedestrianWaypoints) {
                        const dist = ped.mesh.position.distanceTo(new THREE.Vector3(waypoint.x, 0, waypoint.z));
                        if (dist < nearestDist) {
                            nearestDist = dist;
                            nearestHouse = waypoint;
                        }
                    }
                    
                    ped.state = 'fleeing';
                    ped.speed = pedestrianRunSpeed;
                    ped.fleeTarget = new THREE.Vector3(nearestHouse.x, 0, nearestHouse.z);
                    ped.target = ped.fleeTarget;
                }
            }
        }

        function checkPedestrianBulletCollisions(projectile) {
            for (const ped of pedestrians) {
                if (ped.isDead) continue;
                
                const pedCenter = ped.mesh.position.clone().add(new THREE.Vector3(0, pedestrianCenterHeight, 0));
                const dist = projectile.mesh.position.distanceTo(pedCenter);
                
                if (dist < pedestrianCollisionRadius) {
                    // Pedestrian is hit
                    ped.isDead = true;
                    ped.state = 'dead';
                    
                    // Make body fall over
                    ped.mesh.rotation.x = Math.PI / 2;
                    ped.mesh.position.y = pedestrianFallenHeight;
                    
                    // Create blood pool
                    createBloodPool(ped.mesh.position.clone());
                    
                    return true; // Hit detected
                }
            }
            return false;
        }

        // Telephone pole event
        const poleEventLocation = new THREE.Vector3(-521, 0, -93.26);
        const poleEventTriggerDistance = 8;
        let isFirstPersonMode = false;
        let isTransitioning = false;
        let poleStarerMesh = null;
        let brokenPoleMesh = null;
        let poleDialogShown = false;
        const transitionOverlay = document.getElementById('transition-overlay');
        const poleDialog = document.getElementById('pole-dialog');
        
        // First person controls
        let fpCameraYaw = 0;
        let fpCameraPitch = 0;
        const fpMouseSensitivity = 0.002;
        const fpMaxPitch = Math.PI / 2 - 0.1;
        const fpMoveSpeed = 0.1;
        const fpKeys = { w: false, a: false, s: false, d: false };
        
        // Camera pan animation state for building entry
        let cameraPanActive = false;
        let cameraPanStartTime = 0;
        let cameraPanDuration = 1000; // milliseconds
        let cameraPanStartYaw = 0;
        let cameraPanStartPitch = 0;
        let cameraPanTargetYaw = 0;
        let cameraPanTargetPitch = 0;
        
        // Dev fly mode
        let devMode = false;
        const devFlySpeed = 1.5;
        const devFlySprintSpeed = 5.0;
        const devFlyKeys = { w: false, a: false, s: false, d: false, space: false, shift: false, sprint: false };
        const devCamPos = new THREE.Vector3(0, 50, 0);
        
        // Create pole starer NPC
        function createPoleStarer() {
            const group = new THREE.Group();
            
            // Body - dark grey coat
            const bodyGeometry = new THREE.BoxGeometry(0.5, 1.5, 0.3);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: 0x2f2f2f });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.75;
            group.add(body);
            
            // Head - pale skin
            const headGeometry = new THREE.BoxGeometry(0.35, 0.35, 0.35);
            const headMaterial = new THREE.MeshLambertMaterial({ color: 0xd4b896 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.7;
            group.add(head);
            
            // Exclamation point above head
            const exclamationGroup = new THREE.Group();
            
            // Exclamation body (vertical bar)
            const exclamationBodyGeo = new THREE.BoxGeometry(0.15, 0.5, 0.15);
            const exclamationMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const exclamationBody = new THREE.Mesh(exclamationBodyGeo, exclamationMat);
            exclamationBody.position.y = 0.35;
            exclamationGroup.add(exclamationBody);
            
            // Exclamation dot
            const exclamationDotGeo = new THREE.BoxGeometry(0.15, 0.15, 0.15);
            const exclamationDot = new THREE.Mesh(exclamationDotGeo, exclamationMat);
            exclamationDot.position.y = 0;
            exclamationGroup.add(exclamationDot);
            
            exclamationGroup.position.y = 2.3;
            group.add(exclamationGroup);
            
            return group;
        }
        
        // Create broken telephone pole
        function createBrokenPole() {
            const group = new THREE.Group();
            
            // Main pole (tilted)
            const poleGeometry = new THREE.CylinderGeometry(0.15, 0.2, 6, 8);
            const poleMaterial = new THREE.MeshLambertMaterial({ color: 0x4a3728 });
            const pole = new THREE.Mesh(poleGeometry, poleMaterial);
            pole.position.y = 2.5;
            pole.rotation.z = 0.3; // Tilted
            pole.rotation.x = 0.1;
            group.add(pole);
            
            // Cross beam (broken/dangling)
            const beamGeometry = new THREE.BoxGeometry(2, 0.1, 0.1);
            const beam = new THREE.Mesh(beamGeometry, poleMaterial);
            beam.position.set(0.5, 4.5, 0);
            beam.rotation.z = 0.5; // Dangling angle
            group.add(beam);
            
            // Dangling wires
            const wireGeometry = new THREE.CylinderGeometry(0.02, 0.02, 3, 4);
            const wireMaterial = new THREE.MeshLambertMaterial({ color: 0x111111 });
            const wire1 = new THREE.Mesh(wireGeometry, wireMaterial);
            wire1.position.set(1, 3, 0);
            wire1.rotation.z = 0.8;
            group.add(wire1);
            
            const wire2 = new THREE.Mesh(wireGeometry, wireMaterial);
            wire2.position.set(-0.5, 3.5, 0);
            wire2.rotation.z = -0.6;
            group.add(wire2);
            
            return group;
        }
        
        // Initialize pole event scene objects
        function initPoleEvent() {
            // Create and position the broken pole
            brokenPoleMesh = createBrokenPole();
            brokenPoleMesh.position.set(poleEventLocation.x + 3, 0, poleEventLocation.z);
            scene.add(brokenPoleMesh);
            
            // Create and position the starer, looking at the pole
            poleStarerMesh = createPoleStarer();
            poleStarerMesh.position.set(poleEventLocation.x, 0, poleEventLocation.z);
            // Face the pole
            poleStarerMesh.rotation.y = Math.PI / 2; // Facing the pole
            scene.add(poleStarerMesh);
        }
        
        // Check if player is near pole event
        function checkPoleEventProximity() {
            const distToEvent = myPosition.distanceTo(poleEventLocation);
            
            if (distToEvent < poleEventTriggerDistance && !isFirstPersonMode && !isTransitioning) {
                // Start transition to first person mode
                isTransitioning = true;
                transitionOverlay.style.opacity = '1';
                
                // Set initial FP camera direction to face the starer NPC
                const toStarer = poleStarerMesh.position.clone().sub(myPosition);
                fpCameraYaw = Math.atan2(-toStarer.x, -toStarer.z);
                fpCameraPitch = 0;
                
                setTimeout(() => {
                    isFirstPersonMode = true;
                    if (localPlayerMesh) localPlayerMesh.visible = false;
                    // Only request pointer lock on desktop (not mobile)
                    if (!isMobile) {
                        renderer.domElement.requestPointerLock();
                    }
                    
                    // Show FPS UI elements
                    document.getElementById('crosshair').style.display = 'block';
                    document.getElementById('weapon-display').style.display = 'block';
                    updateWeaponDisplay();
                    
                    setTimeout(() => {
                        transitionOverlay.style.opacity = '0';
                        isTransitioning = false;
                        
                        // Show dialog after transition completes
                        if (!poleDialogShown) {
                            poleDialogShown = true;
                            poleDialog.style.display = 'block';
                            if (!isMobile) {
                                document.exitPointerLock();
                            }
                        }
                    }, 100);
                }, 500);
            } else if (distToEvent >= poleEventTriggerDistance + 2 && isFirstPersonMode && !isTransitioning) {
                // Start transition out of first person mode
                isTransitioning = true;
                transitionOverlay.style.opacity = '1';
                // Only exit pointer lock on desktop (not mobile)
                if (!isMobile) {
                    document.exitPointerLock();
                }
                poleDialog.style.display = 'none';
                
                // Hide FPS UI elements
                document.getElementById('crosshair').style.display = 'none';
                document.getElementById('weapon-display').style.display = 'none';
                
                setTimeout(() => {
                    isFirstPersonMode = false;
                    if (localPlayerMesh) localPlayerMesh.visible = true;
                    
                    setTimeout(() => {
                        transitionOverlay.style.opacity = '0';
                        isTransitioning = false;
                    }, 100);
                }, 500);
            }
        }
        
        // Toggle between first-person and isometric camera modes (for mobile button)
        function toggleCameraMode() {
            // Don't allow toggle during certain states
            if (inHouse || isTransitioning || isRagdoll || isPlayerDead) return;
            
            // Don't allow toggle near pole event to avoid conflicts with automatic FP transition
            // (prevents user toggle from interfering with scripted camera sequence)
            const distToEvent = myPosition.distanceTo(poleEventLocation);
            if (distToEvent < poleEventTriggerDistance + cameraTogglePoleEventBufferDistance) return;
            
            isFirstPersonMode = !isFirstPersonMode;
            
            if (isFirstPersonMode) {
                // Switching to first-person
                if (localPlayerMesh) localPlayerMesh.visible = false;
                
                // Show crosshair and weapon display
                document.getElementById('crosshair').style.display = 'block';
                document.getElementById('weapon-display').style.display = 'block';
                
                // Initialize camera orientation to face forward
                fpCameraYaw = playerYaw;
                fpCameraPitch = 0;
                
            } else {
                // Switching to isometric
                if (localPlayerMesh) localPlayerMesh.visible = true;
                
                // Hide crosshair and weapon display
                document.getElementById('crosshair').style.display = 'none';
                document.getElementById('weapon-display').style.display = 'none';
                
                // Reset camera position
                updateCameraPosition();
            }
        }
        
        // Update weapon display UI
        function updateWeaponDisplay() {
            const weaponNameEl = document.getElementById('weapon-name');
            if (weaponNameEl) {
                weaponNameEl.textContent = weapons[currentWeaponIndex].name;
            }
        }

        houseLeaveBtn.addEventListener('click', () => {
            houseDialogEl.style.display = 'none';
            exitHouse();
        });

        houseAttackBtn.addEventListener('click', () => {
            startCombat();
        });

        corpseLootBtn.addEventListener('click', () => {
            const coins = Math.floor(randomRange(10, 60));
            addKajCoins(coins);
            corpseDialogTextEl.innerHTML = `You loot the corpse. It feels wrong.<br>+${coins} Kaj Coins.`;
            corpseLootBtn.disabled = true;
        });

        corpseEatBtn.addEventListener('click', () => {
            const heal = Math.floor(randomRange(10, 30));
            restoreHealth(heal);
            corpseDialogTextEl.innerHTML = `You stare at the body and eat. Disgusting.<br>+${heal} HP.`;
            corpseEatBtn.disabled = true;
        });

        corpseRemoroBtn.addEventListener('click', () => {
            const chooseLoot = Math.random() < 0.5;
            if (chooseLoot) {
                const line = remoroLootLines[Math.floor(Math.random() * remoroLootLines.length)];
                const coins = Math.floor(randomRange(15, 75));
                addKajCoins(coins);
                corpseDialogTextEl.innerHTML = `Remoro: "${line}"<br>+${coins} Kaj Coins.`;
            } else {
                const line = remoroEatLines[Math.floor(Math.random() * remoroEatLines.length)];
                const heal = Math.floor(randomRange(10, 25));
                restoreHealth(heal);
                corpseDialogTextEl.innerHTML = `Remoro: "${line}"<br>+${heal} HP.`;
            }
            corpseRemoroBtn.disabled = true;
        });

        corpseLeaveBtn.addEventListener('click', () => {
            exitHouse();
        });

        combatAttackBtn.addEventListener('click', () => handlePlayerAction('attack'));
        combatTalkBtn.addEventListener('click', () => handlePlayerAction('talk'));
        combatDefendBtn.addEventListener('click', () => handlePlayerAction('defend'));
        combatFleeBtn.addEventListener('click', () => handlePlayerAction('flee'));
        
        // Dialog option handlers
        const noAnswerDialog = document.getElementById('no-answer-dialog');
        const remoroDialog = document.getElementById('remoro-dialog');
        const deadBoyDialog = document.getElementById('dead-boy-dialog');
        const talkIndicator = document.getElementById('talk-indicator');
        let bloodPool = null;
        let boyIsDead = false;
        
        // Create blood pool
        function createBloodPool(position) {
            const geometry = new THREE.CircleGeometry(0.8, 16);
            const material = new THREE.MeshBasicMaterial({ color: 0x8b0000, side: THREE.DoubleSide });
            const pool = new THREE.Mesh(geometry, material);
            pool.rotation.x = -Math.PI / 2;
            pool.position.set(position.x, 0.01, position.z);
            scene.add(pool);
            return pool;
        }
        
        // Boy explosion and death sequence
        function playBoyDeathSequence() {
            if (!poleStarerMesh) return;
            
            // Play explosion sound
            playSound(explosionSound);
            
            // Create explosion effect at boy's position
            const boyPos = poleStarerMesh.position.clone();
            const explosion = new THREE.Mesh(
                new THREE.SphereGeometry(1, 16, 16),
                new THREE.MeshBasicMaterial({ color: 0xff4400, transparent: true, opacity: 0.8 })
            );
            explosion.position.copy(boyPos).add(new THREE.Vector3(0, 1, 0));
            scene.add(explosion);
            
            // Animate explosion
            let scale = 0.1;
            const expandExplosion = () => {
                scale += 0.2;
                explosion.scale.set(scale, scale, scale);
                explosion.material.opacity -= 0.1;
                if (explosion.material.opacity > 0) {
                    requestAnimationFrame(expandExplosion);
                } else {
                    scene.remove(explosion);
                }
            };
            expandExplosion();
            
            // Make the boy fall over (ragdoll)
            poleStarerMesh.rotation.x = -Math.PI / 2;
            poleStarerMesh.position.y = 0.3;
            
            // Remove exclamation point (last child)
            const exclamation = poleStarerMesh.children.find(c => c.type === 'Group');
            if (exclamation) poleStarerMesh.remove(exclamation);
            
            // Create blood pool
            bloodPool = createBloodPool(boyPos);
            
            // Expand blood pool over time
            let poolScale = 0.3;
            const expandPool = () => {
                poolScale += 0.05;
                if (bloodPool && poolScale < 1.5) {
                    bloodPool.scale.set(poolScale, poolScale, 1);
                    requestAnimationFrame(expandPool);
                }
            };
            expandPool();
            
            // Mark boy as dead
            boyIsDead = true;
            
            // After a delay, pan camera to Remoro
            setTimeout(() => {
                panCameraToRemoro();
            }, 1500);
        }
        
        // Pan camera to Remoro and show dialog
        function panCameraToRemoro() {
            if (!remoroMesh) return;
            
            // Calculate direction to face Remoro
            const toRemoro = remoroMesh.position.clone().sub(myPosition);
            const targetYaw = Math.atan2(-toRemoro.x, -toRemoro.z);
            
            // Animate camera rotation to face Remoro
            const startYaw = fpCameraYaw;
            const startPitch = fpCameraPitch;
            const duration = 1000;
            const startTime = performance.now();
            
            const animateCamera = () => {
                const elapsed = performance.now() - startTime;
                const t = Math.min(elapsed / duration, 1);
                const easeT = t * t * (3 - 2 * t); // Smoothstep
                
                fpCameraYaw = startYaw + (targetYaw - startYaw) * easeT;
                fpCameraPitch = startPitch + (0 - startPitch) * easeT;
                
                if (t < 1) {
                    requestAnimationFrame(animateCamera);
                } else {
                    // Show Remoro's dialog
                    document.exitPointerLock();
                    remoroDialog.style.display = 'block';
                }
            };
            animateCamera();
        }
        
        document.querySelectorAll('.dialog-option').forEach(option => {
            option.addEventListener('click', (e) => {
                const choice = e.target.dataset.option;
                poleDialog.style.display = 'none';
                
                // Handle different choices
                if (choice === '1') {
                    // Show "no one picked up" dialog
                    noAnswerDialog.style.display = 'block';
                } else if (choice === '2') {
                    // Boy grabs wire and explodes
                    renderer.domElement.requestPointerLock();
                    playBoyDeathSequence();
                } else if (choice === '3') {
                    renderer.domElement.requestPointerLock();
                    const blastPos = poleStarerMesh ? poleStarerMesh.position.clone() : myPosition.clone();
                    createExplosion(blastPos, 3);
                    setTimeout(() => {
                        triggerPlayerDeath('wire');
                    }, 600);
                }
            });
        });
        
        // No answer dialog continue button
        document.getElementById('no-answer-continue').addEventListener('click', () => {
            noAnswerDialog.style.display = 'none';
            renderer.domElement.requestPointerLock();
        });
        
        // Remoro dialog continue button
        document.getElementById('remoro-continue').addEventListener('click', () => {
            remoroDialog.style.display = 'none';
            renderer.domElement.requestPointerLock();
        });
        
        // Remoro random speech system
        const remoroTalkDialog = document.getElementById('remoro-talk-dialog');
        const remoroTalkText = document.getElementById('remoro-talk-text');
        const remoroQuotes = [
            "The FBI Killed Martin Luther King",
            "Fuck you",
            "You owe me 73 dollars for the Gas Bill",
            "Why are we here. Just to suffer"
        ];
        
        // Check if player is facing Remoro
        function isFacingRemoro() {
            if (!remoroMesh || !isFirstPersonMode) return false;
            
            // Get direction player is facing
            const playerDir = new THREE.Vector3(
                -Math.sin(fpCameraYaw),
                0,
                -Math.cos(fpCameraYaw)
            ).normalize();
            
            // Get direction to Remoro
            const toRemoro = remoroMesh.position.clone().sub(myPosition);
            const distToRemoro = toRemoro.length();
            toRemoro.y = 0;
            toRemoro.normalize();
            
            // Check dot product (facing direction) and distance
            const dot = playerDir.dot(toRemoro);
            return dot > 0.7 && distToRemoro < 5; // Facing within ~45 degrees and within 5 units
        }
        
        // Talk to Remoro
        function talkToRemoro() {
            if (!isFacingRemoro()) return;
            
            const randomQuote = remoroQuotes[Math.floor(Math.random() * remoroQuotes.length)];
            remoroTalkText.textContent = '"' + randomQuote + '"';
            remoroTalkDialog.style.display = 'block';
            document.exitPointerLock();
        }
        
        // Remoro talk dialog continue button
        document.getElementById('remoro-talk-continue').addEventListener('click', () => {
            remoroTalkDialog.style.display = 'none';
            renderer.domElement.requestPointerLock();
        });
        
        // Dead boy dialog continue button
        document.getElementById('dead-boy-continue').addEventListener('click', () => {
            deadBoyDialog.style.display = 'none';
            renderer.domElement.requestPointerLock();
        });
        
        // Check if player is facing dead boy
        function isFacingDeadBoy() {
            if (!poleStarerMesh || !isFirstPersonMode || !boyIsDead) return false;
            
            // Get direction player is facing
            const playerDir = new THREE.Vector3(
                -Math.sin(fpCameraYaw),
                0,
                -Math.cos(fpCameraYaw)
            ).normalize();
            
            // Get direction to dead boy
            const toBoy = poleStarerMesh.position.clone().sub(myPosition);
            const distToBoy = toBoy.length();
            toBoy.y = 0;
            toBoy.normalize();
            
            // Check dot product (facing direction) and distance
            const dot = playerDir.dot(toBoy);
            return dot > 0.7 && distToBoy < 5; // Facing within ~45 degrees and within 5 units
        }
        
        // Talk to dead boy
        function talkToDeadBoy() {
            if (!isFacingDeadBoy()) return;
            
            deadBoyDialog.style.display = 'block';
            document.exitPointerLock();
        }
        
        // Update talk indicator visibility
        function updateTalkIndicator() {
            if (!isFirstPersonMode) {
                talkIndicator.style.display = 'none';
                return;
            }
            
            if (isFacingRemoro() || isFacingDeadBoy()) {
                talkIndicator.style.display = 'block';
            } else {
                talkIndicator.style.display = 'none';
            }
        }

        // Weapon audio
        const pistolFireSound = new Audio('/media/mp3/pistol_fire3.mp3');
        const smgFireSound = new Audio('/media/hl2-smg-shot.mp3');
        const explosionSound = new Audio('/media/explosion-meme_dTCfAHs.mp3');
        pistolFireSound.volume = 0.35;
        smgFireSound.volume = 0.3;
        explosionSound.volume = 0.4;

        function playSound(sound) {
            const instance = sound.cloneNode();
            instance.volume = sound.volume;
            instance.play().catch(() => {});
        }

        // V.A.T.S. system
        let vatsActive = false;
        let vatsTargetId = null;
        let vatsTargetPart = 'body';
        let vatsShots = 1;
        let vatsLabel = null;
        let vatsHeadHighlight = null;
        let vatsBodyHighlight = null;
        let cinematicActive = false;
        let cinematicEndTime = 0;
        let cinematicData = null;
        let cinematicRestore = null;

        function getPlayerPositionById(playerId) {
            if (playerId === myPlayerId) {
                return myPosition.clone().add(new THREE.Vector3(0, 1.7, 0));
            }
            const other = otherPlayers.get(playerId);
            if (!other) return null;
            return other.mesh.position.clone().add(new THREE.Vector3(0, 1.7, 0));
        }

        function getClosestTarget() {
            let closest = null;
            let closestDist = Infinity;
            for (const [playerId, playerObj] of otherPlayers) {
                if (playerObj.ragdoll) continue;
                const targetPos = playerObj.mesh.position.clone().add(new THREE.Vector3(0, 1.2, 0));
                const dist = targetPos.distanceTo(myPosition);
                if (dist < closestDist && dist < 120) {
                    closestDist = dist;
                    closest = { id: playerId, mesh: playerObj.mesh, distance: dist };
                }
            }
            return closest;
        }

        function computeVatsChances(distance) {
            const headBase = 0.55;
            const bodyBase = 0.85;
            const drop = Math.min(distance / 200, 1) * 0.4;
            return {
                head: Math.max(0.05, Math.min(0.95, headBase - drop)),
                body: Math.max(0.1, Math.min(0.95, bodyBase - drop))
            };
        }

        function createVatsLabel() {
            const div = document.createElement('div');
            div.style.cssText = 'color:#7CFF7C;font-family:Arial,sans-serif;font-size:14px;font-weight:bold;background:rgba(0,0,0,0.6);padding:6px 8px;border-radius:4px;white-space:nowrap;text-align:left;';
            return new CSS2DObject(div);
        }

        function attachVatsHighlights(targetMesh) {
            const headMat = new THREE.MeshBasicMaterial({ color: 0xff5555, transparent: true, opacity: 0.35, wireframe: true, depthTest: false });
            const bodyMat = new THREE.MeshBasicMaterial({ color: 0x55ff55, transparent: true, opacity: 0.25, wireframe: true, depthTest: false });
            vatsHeadHighlight = new THREE.Mesh(new THREE.SphereGeometry(0.25, 12, 12), headMat);
            vatsBodyHighlight = new THREE.Mesh(new THREE.BoxGeometry(0.6, 1.4, 0.4), bodyMat);
            vatsHeadHighlight.position.set(0, 1.7, 0);
            vatsBodyHighlight.position.set(0, 0.75, 0);
            targetMesh.add(vatsHeadHighlight);
            targetMesh.add(vatsBodyHighlight);
        }

        function clearVatsHighlights() {
            if (vatsHeadHighlight && vatsHeadHighlight.parent) {
                vatsHeadHighlight.parent.remove(vatsHeadHighlight);
            }
            if (vatsBodyHighlight && vatsBodyHighlight.parent) {
                vatsBodyHighlight.parent.remove(vatsBodyHighlight);
            }
            vatsHeadHighlight = null;
            vatsBodyHighlight = null;
        }

        function updateVatsDisplay() {
            const target = otherPlayers.get(vatsTargetId);
            if (!target) {
                exitVats();
                return;
            }
            const distance = target.mesh.position.distanceTo(myPosition);
            const chances = computeVatsChances(distance);
            const headPercent = Math.round(chances.head * 100);
            const bodyPercent = Math.round(chances.body * 100);
            if (!vatsLabel) {
                vatsLabel = createVatsLabel();
                vatsLabel.position.set(0, 2.6, 0);
                target.mesh.add(vatsLabel);
            }
            vatsLabel.element.innerHTML = `Head ${headPercent}% (H)<br>Body ${bodyPercent}% (B)<br>Shots ${vatsShots} (1-3)`;

            if (vatsHeadHighlight && vatsBodyHighlight) {
                const headSelected = vatsTargetPart === 'head';
                vatsHeadHighlight.material.opacity = headSelected ? 0.6 : 0.2;
                vatsBodyHighlight.material.opacity = headSelected ? 0.15 : 0.45;
            }
        }

        function enterVats() {
            if (vatsActive) return;
            const target = getClosestTarget();
            if (!target) return;
            vatsActive = true;
            vatsTargetId = target.id;
            vatsTargetPart = 'body';
            vatsShots = 1;
            attachVatsHighlights(target.mesh);
            updateVatsDisplay();
        }

        function exitVats() {
            vatsActive = false;
            vatsTargetId = null;
            vatsTargetPart = 'body';
            vatsShots = 1;
            if (vatsLabel && vatsLabel.parent) {
                vatsLabel.parent.remove(vatsLabel);
            }
            vatsLabel = null;
            clearVatsHighlights();
        }

        function startVatsCinematic(data) {
            cinematicActive = true;
            cinematicEndTime = performance.now() + 2200;
            cinematicData = data;
            timeScale = 0.2;
            cinematicRestore = {
                position: camera.position.clone(),
                rotation: camera.rotation.clone()
            };

            const weaponName = data.weapon;
            for (let i = 0; i < data.shots; i++) {
                setTimeout(() => {
                    if (weaponName === 'Pistol') {
                        playSound(pistolFireSound);
                    } else if (weaponName === 'Rifle' || weaponName === 'Shotgun') {
                        playSound(smgFireSound);
                    }
                }, i * 250);
            }

            if (weaponName === 'RPG' && data.success) {
                setTimeout(() => {
                    const targetPos = getPlayerPositionById(data.targetId);
                    if (targetPos) {
                        createExplosion(targetPos.clone(), 3);
                    }
                }, 600);
            }
        }

        function endVatsCinematic() {
            cinematicActive = false;
            timeScale = 1;
            // Reset camera to isometric follow position
            if (localPlayerMesh) {
                updateCameraPosition();
            }
            cinematicData = null;
            cinematicRestore = null;
        }

        function updateVatsCinematic() {
            if (!cinematicActive || !cinematicData) return;
            if (performance.now() >= cinematicEndTime) {
                endVatsCinematic();
                return;
            }
            const shooterPos = getPlayerPositionById(cinematicData.shooterId);
            const targetPos = getPlayerPositionById(cinematicData.targetId);
            if (!shooterPos || !targetPos) return;
            const toTarget = targetPos.clone().sub(shooterPos).normalize();
            const camPos = shooterPos.clone()
                .add(toTarget.clone().multiplyScalar(-3.5))
                .add(new THREE.Vector3(0, 1.5, 0));
            camera.position.copy(camPos);
            camera.lookAt(targetPos.clone().add(new THREE.Vector3(0, 1.0, 0)));
        }

        function executeVats() {
            if (!vatsActive || !vatsTargetId) return;
            const target = otherPlayers.get(vatsTargetId);
            if (!target) {
                exitVats();
                return;
            }
            const distance = target.mesh.position.distanceTo(myPosition);
            const chances = computeVatsChances(distance);
            const chance = vatsTargetPart === 'head' ? chances.head : chances.body;
            let hits = 0;
            for (let i = 0; i < vatsShots; i++) {
                if (Math.random() < chance) hits++;
            }
            const success = hits > 0;
            const weapon = weapons[currentWeaponIndex].name;

            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({
                    type: 'vats',
                    targetId: vatsTargetId,
                    part: vatsTargetPart,
                    shots: vatsShots,
                    weapon: weapon,
                    success: success
                }));
            }

            startVatsCinematic({
                shooterId: myPlayerId,
                targetId: vatsTargetId,
                part: vatsTargetPart,
                shots: vatsShots,
                weapon: weapon,
                success: success
            });
            exitVats();
        }
        
        // Coordinates display
        const coordsDiv = document.getElementById('coords');
        
        // Multiplayer setup
        let myPlayerId = null;
        let myPlayerName = 'Player';
        let socket = null;
        const otherPlayers = new Map(); // Map of playerId -> { mesh, label }
        
        // Create player model (rectangle/box)
        function createPlayerModel(color = 0x00ff00) {
            const group = new THREE.Group();
            
            // Body (rectangle)
            const bodyGeometry = new THREE.BoxGeometry(0.5, 1.5, 0.3);
            const bodyMaterial = new THREE.MeshLambertMaterial({ color: color });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.75;
            group.add(body);
            
            // Head
            const headGeometry = new THREE.BoxGeometry(0.35, 0.35, 0.35);
            const headMaterial = new THREE.MeshLambertMaterial({ color: 0xffcc99 });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.7;
            group.add(head);
            
            return group;
        }
        
        // Create nametag
        function createNametag(name) {
            const div = document.createElement('div');
            div.className = 'nametag';
            div.textContent = name;
            div.style.cssText = 'color:white;font-family:Arial,sans-serif;font-size:14px;font-weight:bold;background:rgba(0,0,0,0.6);padding:2px 8px;border-radius:4px;white-space:nowrap;';
            const label = new CSS2DObject(div);
            label.position.set(0, 2.2, 0);
            return label;
        }
        
        // Add or update other player
        function updateOtherPlayer(playerData) {
            if (playerData.id === myPlayerId) return; // Skip self
            
            let playerObj = otherPlayers.get(playerData.id);
            
            if (!playerObj) {
                // Create new player
                const mesh = createPlayerModel(0x3498db); // Blue for other players
                const label = createNametag(playerData.name);
                mesh.add(label);
                scene.add(mesh);
                playerObj = { mesh, label, ragdoll: false };
                otherPlayers.set(playerData.id, playerObj);
            }
            
            // Update position and rotation (use Y for jump sync)
            playerObj.mesh.position.set(playerData.x, playerData.y - 1.7, playerData.z);
            playerObj.mesh.rotation.y = playerData.yaw;
            
            // Update ragdoll state if changed
            if (playerData.ragdoll !== undefined && playerData.ragdoll !== playerObj.ragdoll) {
                playerObj.ragdoll = playerData.ragdoll;
                if (playerData.ragdoll) {
                    // Ragdoll animation - tilt backwards
                    playerObj.mesh.rotation.x = -Math.PI / 2;
                } else {
                    // Stand back up
                    playerObj.mesh.rotation.x = 0;
                }
            }
        }
        
        // Remove player
        function removePlayer(playerId) {
            const playerObj = otherPlayers.get(playerId);
            if (playerObj) {
                scene.remove(playerObj.mesh);
                otherPlayers.delete(playerId);
            }
        }
        
        // Create projectile visual
        function createProjectile(startPos, direction, weapon) {
            const geometry = weapon.explosive 
                ? new THREE.SphereGeometry(0.15, 8, 8)
                : new THREE.SphereGeometry(0.05, 8, 8);
            const material = new THREE.MeshBasicMaterial({ 
                color: weapon.explosive ? 0xff6600 : (weapon.pellets ? 0xff4444 : 0xffff00)
            });
            const projectile = new THREE.Mesh(geometry, material);
            projectile.position.copy(startPos);
            scene.add(projectile);
            
            return {
                mesh: projectile,
                direction: direction.clone(),
                speed: weapon.projectileSpeed,
                distance: 0,
                maxDistance: weapon.range,
                explosive: weapon.explosive,
                damage: weapon.damage,
                weaponName: weapon.name
            };
        }
        
        // Create explosion effect
        function createExplosion(position, radius) {
            const explosion = new THREE.Mesh(
                new THREE.SphereGeometry(radius, 16, 16),
                new THREE.MeshBasicMaterial({ color: 0xff4400, transparent: true, opacity: 0.8 })
            );
            explosion.position.copy(position);
            scene.add(explosion);

            playSound(explosionSound);
            
            // Animate explosion
            let scale = 0.1;
            const expandExplosion = () => {
                scale += 0.15;
                explosion.scale.set(scale, scale, scale);
                explosion.material.opacity -= 0.08;
                if (explosion.material.opacity > 0) {
                    requestAnimationFrame(expandExplosion);
                } else {
                    scene.remove(explosion);
                }
            };
            expandExplosion();
            
            // Check for players in blast radius and hit them
            for (const [playerId, playerObj] of otherPlayers) {
                if (playerObj.ragdoll) continue;
                const dist = position.distanceTo(playerObj.mesh.position.clone().add(new THREE.Vector3(0, 1, 0)));
                if (dist < radius * 2) {
                    if (socket && socket.readyState === WebSocket.OPEN) {
                        socket.send(JSON.stringify({
                            type: 'shoot',
                            targetId: playerId,
                            damage: 100,
                            weapon: 'RPG'
                        }));
                    }
                }
            }
        }
        
        // Player facing direction (yaw)
        let playerYaw = 0;
        
        // Shoot weapon
        function shoot() {
            if (isRagdoll || !localPlayerMesh) return;
            
            const now = Date.now();
            const weapon = weapons[currentWeaponIndex];
            
            if (now - lastFireTime < weapon.fireRate) return;
            lastFireTime = now;

            if (!weapon.explosive) {
                if (weapon.name === 'Pistol') {
                    playSound(pistolFireSound);
                } else if (weapon.name === 'Rifle' || weapon.name === 'Shotgun') {
                    playSound(smgFireSound);
                }
            }
            
            // Trigger viewmodel recoil in first person
            if (isFirstPersonMode) {
                triggerViewmodelRecoil();
            }
            
            // Make nearby pedestrians flee
            makeNearbyPedestriansFlee(myPosition.clone());
            
            // Calculate shooting direction based on view mode
            let direction;
            if (isFirstPersonMode) {
                // First person: shoot where camera is looking
                direction = new THREE.Vector3(
                    -Math.sin(fpCameraYaw) * Math.cos(fpCameraPitch),
                    Math.sin(fpCameraPitch),
                    -Math.cos(fpCameraYaw) * Math.cos(fpCameraPitch)
                ).normalize();
            } else {
                // Isometric: shoot in player facing direction
                direction = new THREE.Vector3(
                    -Math.sin(playerYaw),
                    0,
                    -Math.cos(playerYaw)
                ).normalize();
            }
            
            const pelletCount = weapon.pellets || 1;
            
            for (let i = 0; i < pelletCount; i++) {
                // Apply spread
                const spreadDir = direction.clone();
                spreadDir.x += (Math.random() - 0.5) * weapon.spread * 2;
                if (isFirstPersonMode) {
                    spreadDir.y += (Math.random() - 0.5) * weapon.spread * 2;
                }
                spreadDir.z += (Math.random() - 0.5) * weapon.spread * 2;
                spreadDir.normalize();
                
                // Create projectile visual from player position
                const startPos = myPosition.clone();
                startPos.y = isFirstPersonMode ? 1.7 : 1; // Eye level in FP, chest in isometric
                startPos.add(direction.clone().multiplyScalar(0.5)); // Start slightly in front
                const projectile = createProjectile(startPos, spreadDir, weapon);
                projectiles.push(projectile);
            }
            
            // Notify server of shot fired (for effects)
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({
                    type: 'fire',
                    weapon: weapon.name,
                    x: myPosition.x,
                    y: myPosition.y + 1,
                    z: myPosition.z,
                    yaw: isFirstPersonMode ? fpCameraYaw : playerYaw,
                    pitch: isFirstPersonMode ? fpCameraPitch : 0
                }));
            }
        }
        
        // Update projectiles
        function updateProjectiles() {
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                const moveAmount = p.direction.clone().multiplyScalar(p.speed * timeScale);
                p.mesh.position.add(moveAmount);
                p.distance += p.speed * timeScale;
                
                // Check for pedestrian hits
                if (checkPedestrianBulletCollisions(p)) {
                    scene.remove(p.mesh);
                    projectiles.splice(i, 1);
                    continue;
                }
                
                // Check for hits while projectile travels (for RPG and all weapons)
                for (const [playerId, playerObj] of otherPlayers) {
                    if (playerObj.ragdoll) continue;
                    
                    const playerCenter = playerObj.mesh.position.clone().add(new THREE.Vector3(0, 1, 0));
                    const dist = p.mesh.position.distanceTo(playerCenter);
                    
                    // Hit detection based on projectile type
                    const hitRadius = p.explosive ? 1.5 : 0.8;
                    if (dist < hitRadius) {
                        if (p.explosive) {
                            // RPG explodes on impact
                            createExplosion(p.mesh.position.clone(), 3);
                        } else {
                            // Regular hit
                            if (socket && socket.readyState === WebSocket.OPEN) {
                                socket.send(JSON.stringify({
                                    type: 'shoot',
                                    targetId: playerId,
                                    damage: p.damage,
                                    weapon: p.weaponName
                                }));
                            }
                        }
                        scene.remove(p.mesh);
                        projectiles.splice(i, 1);
                        break;
                    }
                }
                
                // Remove if traveled too far
                if (p.distance >= p.maxDistance) {
                    // RPG explodes at max range
                    if (p.explosive) {
                        createExplosion(p.mesh.position.clone(), 3);
                    }
                    scene.remove(p.mesh);
                    projectiles.splice(i, 1);
                }
            }
        }
        
        // Handle being hit (ragdoll)
        function handleHit(shooterName, weaponName) {
            if (isRagdoll) return;
            
            isRagdoll = true;
           
            
            // Send ragdoll state to server
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({
                    type: 'ragdoll',
                    ragdoll: true
                }));
            }
            
            // Get back up after 3.5 seconds
            ragdollTimer = setTimeout(() => {
                isRagdoll = false;
                ragdollOverlay.style.display = 'none';
                
                // Send recovery state to server
                if (socket && socket.readyState === WebSocket.OPEN) {
                    socket.send(JSON.stringify({
                        type: 'ragdoll',
                        ragdoll: false
                    }));
                }
            }, 3500);
        }
        
        // Connect to WebSocket server
        function connectMultiplayer(playerName) {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            socket = new WebSocket(`${protocol}//${window.location.host}`);
            
            socket.onopen = () => {
                console.log('Connected to multiplayer server');
                socket.send(JSON.stringify({
                    type: 'join',
                    name: playerName,
                    x: myPosition.x,
                    y: myPosition.y + 1.7,
                    z: myPosition.z,
                    yaw: playerYaw
                }));
            };
            
            socket.onmessage = (event) => {
                const msg = JSON.parse(event.data);
                
                if (msg.type === 'welcome') {
                    myPlayerId = msg.id;
                    console.log('My player ID:', myPlayerId);
                }
                
                if (msg.type === 'players') {
                    // Get list of current player IDs
                    const currentIds = new Set(msg.players.map(p => p.id));
                    
                    // Remove players who left
                    for (const [id] of otherPlayers) {
                        if (!currentIds.has(id)) {
                            removePlayer(id);
                        }
                    }
                    
                    // Update/add players
                    for (const player of msg.players) {
                        updateOtherPlayer(player);
                    }
                }
                
                if (msg.type === 'hit') {
                    // We got hit by someone
                    handleHit(msg.shooterName, msg.weapon);
                }

                if (msg.type === 'vats') {
                    startVatsCinematic(msg);
                }
            };
            
            socket.onclose = () => {
                console.log('Disconnected from server');
            };
        }
        
        // Send position updates
        let lastUpdateTime = 0;
        function sendPositionUpdate() {
            if (socket && socket.readyState === WebSocket.OPEN) {
                const now = Date.now();
                if (now - lastUpdateTime > 50) { // Send max 20 updates per second
                    socket.send(JSON.stringify({
                        type: 'update',
                        x: myPosition.x,
                        y: myPosition.y + 1.7,
                        z: myPosition.z,
                        yaw: playerYaw
                    }));
                    lastUpdateTime = now;
                }
            }
        }
        
        // Input handling
        const nameInput = document.getElementById('name-input');
        const playerNameInput = document.getElementById('player-name');
        const joinBtn = document.getElementById('join-btn');
        
        // Join game handler
        joinBtn.addEventListener('click', () => {
            myPlayerName = playerNameInput.value.trim() || 'Player';
            nameInput.style.display = 'none';
            
            // Show mobile controls after joining
            if (isMobile) {
                document.getElementById('mobile-controls').classList.add('active');
            }
            
            // Initialize player and camera after joining
            initializePlayer();
            connectMultiplayer(myPlayerName);
        });
        
        playerNameInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                joinBtn.click();
            }
        });
        
        // Initialize player model and click indicator
        function initializePlayer() {
            // Create local player model
            localPlayerMesh = createLocalPlayer();
            localPlayerMesh.position.copy(playerStartPos);
            myPosition.copy(playerStartPos);
            scene.add(localPlayerMesh);
            
            // Create Remoro companion (positioned behind player)
            remoroMesh = createRemoro();
            remoroMesh.position.copy(playerStartPos.clone().add(new THREE.Vector3(remoroFollowDistance, 0, remoroFollowDistance)));
            scene.add(remoroMesh);
            
            // Spawn pedestrian NPCs
            spawnPedestrians();
            
            // Initialize pole event scene
            initPoleEvent();
            
            // Create click indicator
            clickIndicator = createClickIndicator();
            
            // Initialize viewmodel scene for first-person
            initViewmodelScene();
            
            // Position camera for isometric view
            updateCameraPosition();

            updateStatusHud();
        }
        
        // Handle mouse click for movement
        renderer.domElement.addEventListener('click', (event) => {
            if (!localPlayerMesh) return;
            if (isRagdoll) return;
            if (isPlayerDead) return;
            if (inHouse && (houseDialogEl.style.display === 'block' || corpseDialogEl.style.display === 'block' || houseCombatActive)) return;
            
            // In first person mode, click to shoot
            if (isFirstPersonMode) {
                shoot();
                return;
            }
            
            // Calculate mouse position in normalized device coordinates
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Raycast to find ground position
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(ground);
            
            if (intersects.length > 0) {
                const point = intersects[0].point;
                targetPosition = new THREE.Vector3(point.x, 0, point.z);
                
                // Show click indicator
                if (clickIndicator) {
                    clickIndicator.position.set(point.x, 0.1, point.z);
                    clickIndicator.visible = true;
                    
                    // Fade out indicator after a moment
                    setTimeout(() => {
                        if (clickIndicator) clickIndicator.visible = false;
                    }, 500);
                }
            }
        });
        
        // Right click to shoot
        renderer.domElement.addEventListener('contextmenu', (event) => {
            event.preventDefault();
            if (isPlayerDead) return;
            if (inHouse && (houseDialogEl.style.display === 'block' || corpseDialogEl.style.display === 'block' || houseCombatActive)) return;
            shoot();
        });
        
        // Mouse scroll to zoom
        renderer.domElement.addEventListener('wheel', (event) => {
            event.preventDefault();
            if (isMobile) return; // Camera locked on mobile
            const zoomSpeed = 5;
            if (event.deltaY > 0) {
                // Scroll down - zoom out
                cameraZoom = Math.min(maxZoom, cameraZoom + zoomSpeed);
            } else {
                // Scroll up - zoom in
                cameraZoom = Math.max(minZoom, cameraZoom - zoomSpeed);
            }
            updateCameraPosition();
        }, { passive: false });
        
        // Mobile: canvas tap to set target (isometric click-to-move)
        if (isMobile) {
            renderer.domElement.addEventListener('touchstart', (e) => {
                // Ignore if touch is on controls
                if (e.target.closest('#mobile-controls')) return;
                if (!localPlayerMesh || isRagdoll || isPlayerDead) return;
                if (isFirstPersonMode) return;
                if (inHouse) return;
                
                const touch = e.changedTouches[0];
                mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;
                
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObject(ground);
                
                if (intersects.length > 0) {
                    const point = intersects[0].point;
                    targetPosition = new THREE.Vector3(point.x, 0, point.z);
                    
                    if (clickIndicator) {
                        clickIndicator.position.set(point.x, 0.1, point.z);
                        clickIndicator.visible = true;
                        setTimeout(() => { if (clickIndicator) clickIndicator.visible = false; }, 500);
                    }
                }
            }, { passive: true });
        }
        
        // Key event listeners
        document.addEventListener('keydown', (event) => {
            // F12 toggles dev fly mode
            if (event.key === 'F12') {
                event.preventDefault();
                devMode = !devMode;
                document.getElementById('dev-hud').style.display = devMode ? 'block' : 'none';
                if (devMode) {
                    // Enter dev mode: save current pos, request pointer lock
                    devCamPos.copy(camera.position);
                    fpCameraYaw = camera.rotation.y;
                    fpCameraPitch = camera.rotation.x;
                    camera.far = 5000;
                    camera.updateProjectionMatrix();
                    scene.fog = null;
                    renderer.domElement.requestPointerLock();
                } else {
                    // Exit dev mode: restore fog and camera
                    scene.fog = new THREE.Fog(0x87ceeb, 100, 450);
                    camera.far = 500;
                    camera.updateProjectionMatrix();
                    document.exitPointerLock();
                    // Reset fly keys
                    devFlyKeys.w = devFlyKeys.a = devFlyKeys.s = devFlyKeys.d = false;
                    devFlyKeys.space = devFlyKeys.shift = devFlyKeys.sprint = false;
                }
                return;
            }
            
            // Dev mode key handling
            if (devMode) {
                switch(event.key.toLowerCase()) {
                    case 'w': devFlyKeys.w = true; break;
                    case 'a': devFlyKeys.a = true; break;
                    case 's': devFlyKeys.s = true; break;
                    case 'd': devFlyKeys.d = true; break;
                    case ' ': devFlyKeys.space = true; event.preventDefault(); break;
                    case 'control': devFlyKeys.sprint = true; break;
                }
                if (event.key === 'Shift') devFlyKeys.shift = true;
                return;
            }
            
            if (isPlayerDead) return;
            if (event.key.toLowerCase() === 'v') {
                if (vatsActive) {
                    exitVats();
                } else {
                    enterVats();
                }
                return;
            }

            if (vatsActive) {
                const key = event.key.toLowerCase();
                if (key === 'h') {
                    vatsTargetPart = 'head';
                    updateVatsDisplay();
                } else if (key === 'b') {
                    vatsTargetPart = 'body';
                    updateVatsDisplay();
                } else if (key === '1' || key === '2' || key === '3') {
                    vatsShots = parseInt(key, 10);
                    updateVatsDisplay();
                } else if (key === 'enter') {
                    executeVats();
                } else if (key === 'escape') {
                    exitVats();
                }
                return;
            }
            
            // Weapon switching with number keys
            if (event.key >= '1' && event.key <= '4') {
                currentWeaponIndex = parseInt(event.key) - 1;
                updateWeaponDisplay();
            }
            
            // First person WASD controls
            if (isFirstPersonMode) {
                switch(event.key.toLowerCase()) {
                    case 'w': fpKeys.w = true; break;
                    case 'a': fpKeys.a = true; break;
                    case 's': fpKeys.s = true; break;
                    case 'd': fpKeys.d = true; break;
                    case 'e': 
                        if (inHouse && currentHouseIsKaj && isNearBed()) {
                            layInBed();
                            break;
                        }
                        if (inHouse && isNearExit() && houseDialogEl.style.display !== 'block' && corpseDialogEl.style.display !== 'block') {
                            exitHouse();
                            break;
                        }
                        if (isFacingDeadBoy()) {
                            talkToDeadBoy();
                        } else {
                            talkToRemoro();
                        }
                        break;
                }
            }
        });
        
        document.addEventListener('keyup', (event) => {
            // Dev mode key release
            if (devMode) {
                switch(event.key.toLowerCase()) {
                    case 'w': devFlyKeys.w = false; break;
                    case 'a': devFlyKeys.a = false; break;
                    case 's': devFlyKeys.s = false; break;
                    case 'd': devFlyKeys.d = false; break;
                    case ' ': devFlyKeys.space = false; break;
                    case 'control': devFlyKeys.sprint = false; break;
                }
                if (event.key === 'Shift') devFlyKeys.shift = false;
                return;
            }
            // First person WASD controls
            switch(event.key.toLowerCase()) {
                case 'w': fpKeys.w = false; break;
                case 'a': fpKeys.a = false; break;
                case 's': fpKeys.s = false; break;
                case 'd': fpKeys.d = false; break;
            }
        });
        
        // Mouse look for first person mode and dev mode
        document.addEventListener('mousemove', (event) => {
            if (document.pointerLockElement === renderer.domElement) {
                if (devMode) {
                    fpCameraYaw -= event.movementX * fpMouseSensitivity;
                    fpCameraPitch -= event.movementY * fpMouseSensitivity;
                    fpCameraPitch = Math.max(-fpMaxPitch, Math.min(fpMaxPitch, fpCameraPitch));
                    // Normalize yaw to [-PI, PI]
                    while (fpCameraYaw > Math.PI) fpCameraYaw -= 2 * Math.PI;
                    while (fpCameraYaw < -Math.PI) fpCameraYaw += 2 * Math.PI;
                } else if (isFirstPersonMode) {
                    fpCameraYaw -= event.movementX * fpMouseSensitivity;
                    fpCameraPitch -= event.movementY * fpMouseSensitivity;
                    fpCameraPitch = Math.max(-fpMaxPitch, Math.min(fpMaxPitch, fpCameraPitch));
                    // Normalize yaw to [-PI, PI]
                    while (fpCameraYaw > Math.PI) fpCameraYaw -= 2 * Math.PI;
                    while (fpCameraYaw < -Math.PI) fpCameraYaw += 2 * Math.PI;
                }
            }
        });
        
        // Load map parts
        const loadingDiv = document.getElementById('loading');
        const mapParts = [];
        for (let i = 0; i <= 91; i++) {
            mapParts.push('part' + String(i).padStart(4, '0') + '.obj');
        }
        
        let loadedCount = 0;
        const totalParts = mapParts.length;
        
        // Load MTL first, then OBJ files
        const mtlLoader = new MTLLoader();
        mtlLoader.setPath('/anothermapo/');
        
        const objLoader = new OBJLoader();
        objLoader.setPath('/anothermapo/');
        
        // Load materials first, then load OBJ files with materials applied
        mtlLoader.load('materials.mtl', 
            (materials) => {
                materials.preload();
                console.log('Materials loaded:', materials);
                
                // Set materials on OBJ loader
                objLoader.setMaterials(materials);
                
                // Load each OBJ part with materials
                function loadMapPart(partName) {
                    return new Promise((resolve, reject) => {
                        objLoader.load(
                            partName,
                            (object) => {
                                // Optimize: enable frustum culling on all meshes
                                object.traverse((child) => {
                                    if (child.isMesh) {
                                        child.frustumCulled = true;
                                        child.matrixAutoUpdate = false;
                                        child.updateMatrix();
                                        // Only add to collision meshes if tall enough to be a wall (not floor/road)
                                        child.geometry.computeBoundingBox();
                                        const bbox = child.geometry.boundingBox;
                                        if (bbox) {
                                            const height = bbox.max.y - bbox.min.y;
                                            if (height > 1.5) { // Only collide with meshes taller than 1.5 units
                                                child.updateMatrixWorld(true);
                                                child.userData.worldBox = bbox.clone().applyMatrix4(child.matrixWorld);
                                                child.userData.height = height;
                                                collisionMeshes.push(child);
                                            }
                                        }
                                    }
                                });
                                scene.add(object);
                                loadedCount++;
                                loadingDiv.textContent = `Loading map... ${Math.round((loadedCount / totalParts) * 100)}%`;
                                resolve(object);
                            },
                            (progress) => {
                                // Progress callback
                            },
                            (error) => {
                                console.warn(`Failed to load ${partName}:`, error);
                                loadedCount++;
                                resolve(null); // Continue even if one part fails
                            }
                        );
                    });
                }
                
                // Load all map parts sequentially to avoid overwhelming the browser
                Promise.all(mapParts.map(part => loadMapPart(part)))
                    .then(() => {
                        loadingDiv.style.display = 'none';
                        setupKajHouseLabel();
                        console.log('Map loaded successfully with textures');
                    })
                    .catch((error) => {
                        console.error('Error loading map:', error);
                        loadingDiv.textContent = 'Error loading map';
                    });
            },
            (progress) => {
                loadingDiv.textContent = 'Loading materials...';
            },
            (error) => {
                console.error('Error loading materials:', error);
                loadingDiv.textContent = 'Loading map without textures...';
                
                // Fallback: load without materials
                const defaultMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x888888,
                    side: THREE.DoubleSide
                });
                
                function loadMapPartNoMaterials(partName) {
                    return new Promise((resolve) => {
                        objLoader.load(
                            partName,
                            (object) => {
                                object.traverse((child) => {
                                    if (child instanceof THREE.Mesh) {
                                        child.material = defaultMaterial;
                                        child.frustumCulled = true;
                                        child.matrixAutoUpdate = false;
                                        child.updateMatrix();
                                        // Only add to collision meshes if tall enough to be a wall (not floor/road)
                                        child.geometry.computeBoundingBox();
                                        const bbox = child.geometry.boundingBox;
                                        if (bbox) {
                                            const height = bbox.max.y - bbox.min.y;
                                            if (height > 1.5) { // Only collide with meshes taller than 1.5 units
                                                child.updateMatrixWorld(true);
                                                child.userData.worldBox = bbox.clone().applyMatrix4(child.matrixWorld);
                                                child.userData.height = height;
                                                collisionMeshes.push(child);
                                            }
                                        }
                                    }
                                });
                                scene.add(object);
                                loadedCount++;
                                loadingDiv.textContent = `Loading map... ${Math.round((loadedCount / totalParts) * 100)}%`;
                                resolve(object);
                            },
                            null,
                            () => {
                                loadedCount++;
                                resolve(null);
                            }
                        );
                    });
                }
                
                Promise.all(mapParts.map(part => loadMapPartNoMaterials(part)))
                    .then(() => {
                        loadingDiv.style.display = 'none';
                        setupKajHouseLabel();
                    });
            }
        );
        
        // Check collision with buildings using raycasting
        function checkCollision(newPosition) {
            if (collisionMeshes.length === 0) return false;
            
            // Cast rays in 8 directions from player position at different heights
            const directions = [
                new THREE.Vector3(1, 0, 0),
                new THREE.Vector3(-1, 0, 0),
                new THREE.Vector3(0, 0, 1),
                new THREE.Vector3(0, 0, -1),
                new THREE.Vector3(1, 0, 1).normalize(),
                new THREE.Vector3(1, 0, -1).normalize(),
                new THREE.Vector3(-1, 0, 1).normalize(),
                new THREE.Vector3(-1, 0, -1).normalize()
            ];
            
            // Check at multiple heights (feet, waist, chest)
            const heights = [0.2, 0.8, 1.4];
            
            for (const height of heights) {
                const origin = newPosition.clone();
                origin.y += height;
                
                for (const dir of directions) {
                    const ray = new THREE.Raycaster(origin, dir, 0, playerRadius);
                    const intersects = ray.intersectObjects(collisionMeshes, false);
                    
                    if (intersects.length > 0) {
                        return true; // Collision detected
                    }
                }
            }
            
            return false;
        }
        
        // Update isometric camera position to follow player
        function updateCameraPosition() {
            if (isFirstPersonMode) {
                // First person WASD movement
                const forward = new THREE.Vector3(
                    -Math.sin(fpCameraYaw),
                    0,
                    -Math.cos(fpCameraYaw)
                );
                const right = new THREE.Vector3(
                    Math.cos(fpCameraYaw),
                    0,
                    -Math.sin(fpCameraYaw)
                );
                
                // Calculate new position with collision check
                const newPos = myPosition.clone();
                if (fpKeys.w) newPos.add(forward.clone().multiplyScalar(fpMoveSpeed));
                if (fpKeys.s) newPos.add(forward.clone().multiplyScalar(-fpMoveSpeed));
                if (fpKeys.a) newPos.add(right.clone().multiplyScalar(-fpMoveSpeed));
                if (fpKeys.d) newPos.add(right.clone().multiplyScalar(fpMoveSpeed));
                
                // Keep at ground level when outside
                if (!inHouse) newPos.y = 0;
                
                // Only move if no collision
                const hasCollision = inHouse ? checkHouseCollision(newPos) : checkCollision(newPos);
                if (!hasCollision) {
                    myPosition.copy(newPos);
                } else {
                    // Try sliding along walls - check each axis separately
                    const newPosX = myPosition.clone();
                    const newPosZ = myPosition.clone();
                    
                    if (fpKeys.w || fpKeys.s) {
                        const fwdMove = fpKeys.w ? fpMoveSpeed : -fpMoveSpeed;
                        newPosX.add(new THREE.Vector3(forward.x * fwdMove, 0, 0));
                        newPosZ.add(new THREE.Vector3(0, 0, forward.z * fwdMove));
                    }
                    if (fpKeys.a || fpKeys.d) {
                        const sideMove = fpKeys.d ? fpMoveSpeed : -fpMoveSpeed;
                        newPosX.add(new THREE.Vector3(right.x * sideMove, 0, 0));
                        newPosZ.add(new THREE.Vector3(0, 0, right.z * sideMove));
                    }
                    
                    if (!inHouse) {
                        newPosX.y = 0;
                        newPosZ.y = 0;
                    }
                    
                    if (!(inHouse ? checkHouseCollision(newPosX) : checkCollision(newPosX))) {
                        myPosition.x = newPosX.x;
                    }
                    if (!(inHouse ? checkHouseCollision(newPosZ) : checkCollision(newPosZ))) {
                        myPosition.z = newPosZ.z;
                    }
                    // Keep at ground level when outside after any successful move
                    if (!inHouse) myPosition.y = 0;
                }
                
                // Update player mesh position (even though invisible)
                if (localPlayerMesh) localPlayerMesh.position.copy(myPosition);
                
                // First person camera - at player eye level with mouse look
                camera.position.copy(myPosition).add(new THREE.Vector3(0, 1.7, 0));
                camera.rotation.order = 'YXZ';
                camera.rotation.y = fpCameraYaw;
                camera.rotation.x = fpCameraPitch;
                camera.rotation.z = 0; // Ensure no roll
            } else {
                // Isometric camera offset - positioned above and behind player at 45 degree angle
                const cameraOffset = new THREE.Vector3(cameraZoom, cameraZoom, cameraZoom);
                camera.position.copy(myPosition).add(cameraOffset);
                camera.lookAt(myPosition.clone().add(new THREE.Vector3(0, 1, 0)));
            }
        }
        
        // Update player movement (click-to-move)
        function updatePlayer() {
            if (!localPlayerMesh || isRagdoll || isPlayerDead) return;

            if (inHouse) {
                updateHouseMovement();
                if (houseEntryCooldown > 0) houseEntryCooldown--;
                return;
            }
            
            // Move toward target position
            if (targetPosition) {
                const direction = targetPosition.clone().sub(myPosition);
                const distance = direction.length();
                
                if (distance > 0.2) {
                    // Move player
                    direction.normalize();
                    const moveAmount = Math.min(moveSpeed * timeScale, distance);
                    const newPos = myPosition.clone().add(direction.clone().multiplyScalar(moveAmount));
                    newPos.y = 0; // Keep at ground level
                    
                    // Check collision before moving
                    if (!checkCollision(newPos)) {
                        myPosition.copy(newPos);
                    } else {
                        // Try sliding along walls
                        const newPosX = myPosition.clone();
                        newPosX.x += direction.x * moveAmount;
                        newPosX.y = 0;
                        const newPosZ = myPosition.clone();
                        newPosZ.z += direction.z * moveAmount;
                        newPosZ.y = 0;
                        
                        if (!checkCollision(newPosX)) {
                            myPosition.x = newPosX.x;
                        } else if (!checkCollision(newPosZ)) {
                            myPosition.z = newPosZ.z;
                        } else {
                            // Completely blocked, cancel movement
                            targetPosition = null;
                        }
                        // Keep at ground level after any successful move
                        myPosition.y = 0;
                    }
                    
                    // Update player mesh position
                    localPlayerMesh.position.copy(myPosition);
                    
                    // Rotate player to face movement direction
                    playerYaw = Math.atan2(-direction.x, -direction.z);
                    localPlayerMesh.rotation.y = playerYaw;
                } else {
                    // Arrived at target
                    targetPosition = null;
                }
            }
            
            // Mobile joystick movement (overrides click-to-move when active)
            if (isMobile && joystickState.active && (Math.abs(joystickState.dx) > 0.1 || Math.abs(joystickState.dy) > 0.1)) {
                // Cancel any click-to-move target
                targetPosition = null;
                
                // Isometric camera faces along (1,1,1) direction, so we need to rotate joystick input
                // Camera looks from (+X,+Y,+Z) toward origin at 45 degrees
                // Forward (joystick up / -dy) = camera's look direction projected on XZ = (-1, 0, -1) normalized
                // Right (joystick right / +dx) = (1, 0, -1) normalized
                const cos45 = Math.cos(Math.PI / 4);
                const sin45 = Math.sin(Math.PI / 4);
                // -dy = forward in screen = along camera forward on ground
                const isoForwardX = -cos45; // camera forward projected X
                const isoForwardZ = -sin45; // camera forward projected Z
                const isoRightX = sin45;
                const isoRightZ = -cos45;
                
                const moveX = joystickState.dx * isoRightX + (-joystickState.dy) * isoForwardX;
                const moveZ = joystickState.dx * isoRightZ + (-joystickState.dy) * isoForwardZ;
                
                const joyMoveSpeed = moveSpeed * timeScale * 1.2;
                const newPos = myPosition.clone();
                newPos.x += moveX * joyMoveSpeed;
                newPos.z += moveZ * joyMoveSpeed;
                newPos.y = 0; // Keep at ground level
                
                if (!checkCollision(newPos)) {
                    myPosition.copy(newPos);
                } else {
                    // Try sliding
                    const newPosX = myPosition.clone();
                    newPosX.x += moveX * joyMoveSpeed;
                    newPosX.y = 0;
                    const newPosZ = myPosition.clone();
                    newPosZ.z += moveZ * joyMoveSpeed;
                    newPosZ.y = 0;
                    
                    if (!checkCollision(newPosX)) {
                        myPosition.x = newPosX.x;
                    }
                    if (!checkCollision(newPosZ)) {
                        myPosition.z = newPosZ.z;
                    }
                    // Keep at ground level after any successful move
                    myPosition.y = 0;
                }
                
                localPlayerMesh.position.copy(myPosition);
                
                // Rotate player to face movement direction
                if (Math.abs(moveX) > 0.01 || Math.abs(moveZ) > 0.01) {
                    playerYaw = Math.atan2(-moveX, -moveZ);
                    localPlayerMesh.rotation.y = playerYaw;
                }
            }
            
            // Update camera to follow player
            updateCameraPosition();
            
            // Check for pole event proximity
            checkPoleEventProximity();

            // Check for house entry
            checkHouseEntry();
            
            // Update Remoro companion
            updateRemoro();
            
            // Update pedestrians
            updatePedestrians();
            
            // Update talk indicator
            updateTalkIndicator();
            
            // Update coordinates display
            coordsDiv.innerHTML = `X: ${myPosition.x.toFixed(2)}<br>Y: ${myPosition.y.toFixed(2)}<br>Z: ${myPosition.z.toFixed(2)}`;

            if (houseEntryCooldown > 0) houseEntryCooldown--;
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
            if (viewmodelCamera) {
                viewmodelCamera.aspect = window.innerWidth / window.innerHeight;
                viewmodelCamera.updateProjectionMatrix();
            }
        });
        
        // Dev fly mode camera update
        function updateDevFlyCamera() {
            const speed = devFlyKeys.sprint ? devFlySprintSpeed : devFlySpeed;
            
            // Full 3D forward (includes pitch)
            const forward = new THREE.Vector3(
                -Math.sin(fpCameraYaw) * Math.cos(fpCameraPitch),
                Math.sin(fpCameraPitch),
                -Math.cos(fpCameraYaw) * Math.cos(fpCameraPitch)
            );
            const right = new THREE.Vector3(
                Math.cos(fpCameraYaw),
                0,
                -Math.sin(fpCameraYaw)
            );
            
            if (devFlyKeys.w) devCamPos.add(forward.clone().multiplyScalar(speed));
            if (devFlyKeys.s) devCamPos.add(forward.clone().multiplyScalar(-speed));
            if (devFlyKeys.a) devCamPos.add(right.clone().multiplyScalar(-speed));
            if (devFlyKeys.d) devCamPos.add(right.clone().multiplyScalar(speed));
            if (devFlyKeys.space) devCamPos.y += speed;
            if (devFlyKeys.shift) devCamPos.y -= speed;
            
            camera.position.copy(devCamPos);
            camera.rotation.order = 'YXZ';
            camera.rotation.y = fpCameraYaw;
            camera.rotation.x = fpCameraPitch;
            camera.rotation.z = 0;
            
            // Update dev HUD with position
            const hud = document.getElementById('dev-hud');
            hud.textContent = `DEV FLY MODE | X:${devCamPos.x.toFixed(1)} Y:${devCamPos.y.toFixed(1)} Z:${devCamPos.z.toFixed(1)}\nWASD + Space/Shift | Ctrl = Sprint | F12 = Exit`;
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Update camera pan animation if active
            updateCameraPan(performance.now());
            
            if (devMode) {
                updateDevFlyCamera();
            } else if (cinematicActive) {
                updateVatsCinematic();
            } else {
                updatePlayer();
            }
            if (vatsActive) {
                updateVatsDisplay();
            }
            updateProjectiles();
            sendPositionUpdate();
            
            // Update and render viewmodel in first person mode
            updateViewmodel();

            if (inHouse && houseScene) {
                renderer.render(houseScene, camera);
            } else {
                renderer.render(scene, camera);
                labelRenderer.render(scene, camera);
            }
            
            // Render viewmodel on top (only in first person)
            if (isFirstPersonMode && viewmodelScene && viewmodelCamera) {
                renderer.autoClear = false;
                renderer.clearDepth();
                renderer.render(viewmodelScene, viewmodelCamera);
                renderer.autoClear = true;
            }
        }
        
        animate();
    </script>
</body>
</html>